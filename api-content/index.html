{"posts":[{"title":"推荐算法相关","content":"推荐算法是计算机专业中的一种算法，通过一些数学算法，推测出用户可能喜欢的东西，目前应用推荐算法比较好的地方主要是网络，其中淘宝做的比较好。所谓推荐算法就是利用用户的一些行为，通过一些数学算法，推测出用户可能喜欢的东西。推荐算法分为： 1、基于内容 基于内容的推荐(Content-based Recommendation)是信息过滤技术的延续与发展，它是建立在项目的内容信息上做出推荐的，而不需要依据用户对项目的评价意见，更多地需要用机器学习的方法从关于内容的特征描述的事例中得到用户的兴趣资料。 在基于内容的推荐系统中，项目或对象是通过相关特征的属性来定义的，系统基于用户评价对象的特征、学习用户的兴趣，考察用户资料与待预测项目的匹配程度。用户的资料模型取决于所用的学习方法，常用的有决策树、神经网络和基于向量的表示方法等。基于内容的用户资料需要有用户的历史数据，用户资料模型可能随着用户的偏好改变而发生变化。 基于内容的推荐与基于人口统计学的推荐有类似的地方，只不过系统评估的中心转到了物品本身，使用物品本身的相似度而不是用户的相似度来进行推荐。 基于内容的推荐算法的优势在于：对用户兴趣可以很好地建模，并通过对物品属性维度的增加，获得更好的推荐精度。而不足之处就在于：①物品的属性有限，很难有效得到更多数据；②物品相似度的衡量标准只考虑到了物品本身，有一定的片面性；⑨需要用户的物品的历史数据，有冷启动的问题。 2、基于协同 基于协同过滤的推荐算法( Collaborative Filtering Recommendation)技术是推荐系统中应用最早和最为成功的技术之一。它一般采用最近邻技术，利用用户的历史喜好信息计算用户之间的距离，然后利用目标用户的最近邻居用户对商品评价的加权评价值来预测目标用户对特定商品的喜好程度，从而根据这一喜好程度来对目标用户进行推荐。 基于协同过滤的推荐算法最大优点是对推荐对象没有特殊的要求，能处理非结构化的复杂对象，如音乐、电影。 基于协同过滤的推荐算法是基于这样的假设：为一用户找到他真正感兴趣的内容的好方法是首先找到与此用户有相似兴趣的其他用户，然后将他们感兴趣的内容推荐给此用户。其基本思想非常易于理解，在日常生活中，人们往往会利用好朋友的推荐来进行一些选择。基于协同过滤的推荐算法正是把这一思想运用到电子商务推荐系统中来，基于其他用户对某一内容的评价来向目标用户进行推荐。 基于协同过滤的推荐系统可以说是从用户的角度来进行相应推荐的，而且是自动的，即用户获得的推荐是系统从购买模式或浏览行为等隐式获得的，不需要用户努力地找到适合自己兴趣的推荐信息，如填写一些调查表格等。 基于协同过滤的推荐算法具有如下优点： 1)能够过滤难以进行机器自动内容分析的信息，如艺术品、音乐等。 2)共享其他人的经验，避免了内容分析的不完全和不精确，并且能够基于一些复杂的，难以表述的概念（如信息质量、个人品位）进行过滤。 3)有推荐新信息的能力。可以发现内容上完全不相似的信息，用户对推荐信息的内容事先是预料不到的。这也是基于协同过滤的推荐算法和基于内容的推荐一个较大的差别，基于内容的推荐很多都是用户本来就熟悉的内容，而基于协同过滤的推荐可以发现用户潜在的但自己尚未发现的兴趣偏好。 4)能够有效地使用其他相似用户的反馈信息，减少用户的反馈量，加快个性化学习的速度。 3、基于关联规则 基于关联规则的推荐(Association Rule-based Recommendation)是以关联规则为基础，把已购商品作为规则头，规则体为推荐对象。关联规则挖掘可以发现不同商品在销售过程中的相关性，在零售业中已经得到了成功的应用。 关联规则就是在一个交易数据库中统计购买了商品集X的交易中有多大比例的交易同时购买了商品集y，其直观的意义就是用户在购买某些商品的时候有多大倾向去购买另外一些商品。比如购买牛奶的同时很多人会购买面包。 算法的第一步关联规则的发现最为关键且最耗时，是算法的瓶颈，但可以离线进行。其次，商品名称的同义性问题也是关联规则的一个难点。 4、基于效用 基于效用的推荐（Utility-based Recommendation）是建立在对用户使用项目的效用情况上计算的，其核心问题是怎样为每一个用户去创建一个效用函数，因此，用户资料模型很大程度上是由系统所采用的效用函数决定的。 基于效用推荐的好处是它能把非产品的属性，如提供商的可靠性( Vendor Reliability)和产品的可得性( Product Availability)等考虑到效用计算中。 5、基于知识 基于知识的推荐( Knowledge-based Recommendation)在某种程度是可以看成是一种推理(Inference)技术，它不是建立在用户需要和偏好基础上推荐的。 基于知识的方法因它们所用的功能知识不同而有明显区别。效用知识( FunctionalKnowledge)是一种关于一个项目如何满足某一特定用户的知识，因此能解释需要和推荐的关系，所以用户资料可以是任何能支持推理的知识结构，它可以是用户已经规范化的查询，也可以是一个更详细的用户需要的表示。 6、组合推荐 由于各种推荐方法都有优缺点，所以在实际中，组合推荐( Hybrid Recommendation)经常被采用。研究和应用最多的是内容推荐和协同过滤推荐的组合。 最简单的做法就是分别用基于内容的方法和协同过滤推荐方法去产生一个推荐预测结果，然后用某方法组合其结果。尽管从理论上有很多种推荐组合方法，但在某一具体问题中并不见得都有效，组合推荐的一个最重要原则就是通过组合来避免或弥补各自推荐技术的弱点。 在组合方式上，有研究人员提出了七种组合思路。 1)加权（Weight）：加权多种推荐技术结果。 2)变换( Switch);根据问题背景和实际情况或要求决定变换采用不同的推荐技术。 3)混合( Mixed):同时采用多种推荐技术给出多种推荐结果，为用户提供参考。 4)特征组合(Feature Combination):组合来自不同推荐数据源的特征被另一种推荐算法所采用。 5)层叠( Cascade)：先用一种推荐技术产生一种粗糙的推荐结果，第二种推荐技术在此推荐结果的基础上进一步做出更精确的推荐。 6)特征扩充( Feature Augmentation)：将一种技术产生附加的特征信息嵌入另一种推荐技术的特征输入中。 7)元级别( Meta-Ievel):用一种推荐方法产生的模型作为另一种推荐方法的输入。 ","link":"https://gblw-blog.github.io/4VMaPlSLC/"},{"title":"Java脑图","content":" 图床直链：https://s1.328888.xyz/2022/10/14/8duCX.png ","link":"https://gblw-blog.github.io/1MSbQpd6Q/"},{"title":"Mysql-高级总结(2)","content":"一、MySQL存储引擎 1.MySQL体系结构 体系结构的概念 任何一套系统当中，每个部件都能起到一定的作用！ MySQL的体系结构 体系结构详解 客户端连接 支持接口：支持的客户端连接，例如C、Java、PHP等语言来连接MySQL数据库 第一层：网络连接层 连接池：管理、缓冲用户的连接，线程处理等需要缓存的需求。 例如：当客户端发送一个请求连接，会从连接池中获取一个连接进行使用。 第二层：核心服务层 管理服务和工具：系统的管理和控制工具，例如备份恢复、复制、集群等。 SQL接口：接受SQL命令，并且返回查询结果。 查询解析器：验证和解析SQL命令，例如过滤条件、语法结构等。 查询优化器：在执行查询之前，使用默认的一套优化机制进行优化sql语句 缓存：如果缓存当中有想查询的数据，则直接将缓存中的数据返回。没有的话再重新查询！ 第三层：存储引擎层 插件式存储引擎：管理和操作数据的一种机制，包括(存储数据、如何更新、查询数据等) 第四层：系统文件层 文件系统：配置文件、数据文件、日志文件、错误文件、二进制文件等等的保存 2.MySQL存储引擎 引擎的概念 生活中，引擎就是整个机器运行的核心，不同的引擎具备不同的功能。 MySQL存储引擎的概念 MySQL数据库使用不同的机制存取表文件 , 机制的差别在于不同的存储方式、索引技巧、锁定水平以及广泛的不同的功能和能力，在MySQL中 , 将这些不同的技术及配套的功能称为存储引擎 在关系型数据库中数据的存储是以表的形式存进行储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）。 Oracle , SqlServer等数据库只有一种存储引擎 , 而MySQL针对不同的需求, 配置MySQL的不同的存储引擎 , 就会让数据库采取了不同的处理数据的方式和扩展功能。 通过选择不同的引擎 ,能够获取最佳的方案 , 也能够获得额外的速度或者功能，提高程序的整体效果。所以了解引擎的特性 , 才能贴合我们的需求 , 更好的发挥数据库的性能。 MySQL支持的存储引擎 MySQL5.7支持的引擎包括：InnoDB、MyISAM、MEMORY、Archive、Federate、CSV、BLACKHOLE等 其中较为常用的有三种：InnoDB、MyISAM、MEMORY 3.常用引擎的特性对比 常用的存储引擎 MyISAM存储引擎 访问快,不支持事务和外键。表结构保存在.frm文件中，表数据保存在.MYD文件中，索引保存在.MYI文件中。 InnoDB存储引擎(MySQL5.5版本后默认的存储引擎) 支持事务 ,占用磁盘空间大 ,支持并发控制。表结构保存在.frm文件中，如果是共享表空间，数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。如果是多表空间存储，每个表的数据和索引单独保存在 .ibd 中。 MEMORY存储引擎 内存存储 , 速度快 ,不安全 ,适合小量快速访问的数据。表结构保存在.frm中。 特性对比 4.引擎的操作 查询数据库支持的引擎 -- 标准语法 SHOW ENGINES; -- 查询数据库支持的存储引擎 SHOW ENGINES; -- 表含义: - support : 指服务器是否支持该存储引擎 - transactions : 指存储引擎是否支持事务 - XA : 指存储引擎是否支持分布式事务处理 - Savepoints : 指存储引擎是否支持保存点 查询某个数据库中所有数据表的引擎 -- 标准语法 SHOW TABLE STATUS FROM 数据库名称; -- 查看db9数据库所有表的存储引擎 SHOW TABLE STATUS FROM db9; 查询某个数据库中某个数据表的引擎 -- 标准语法 SHOW TABLE STATUS FROM 数据库名称 WHERE NAME = '数据表名称'; -- 查看db9数据库中stu_score表的存储引擎 SHOW TABLE STATUS FROM db9 WHERE NAME = 'stu_score'; 创建数据表，指定存储引擎 -- 标准语法 CREATE TABLE 表名( 列名,数据类型, ... )ENGINE = 引擎名称; -- 创建db11数据库 CREATE DATABASE db11; -- 使用db11数据库 USE db11; -- 创建engine_test表，指定存储引擎为MyISAM CREATE TABLE engine_test( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) )ENGINE = MYISAM; -- 查询engine_test表的引擎 SHOW TABLE STATUS FROM db11 WHERE NAME = 'engine_test'; 修改表的存储引擎 -- 标准语法 ALTER TABLE 表名 ENGINE = 引擎名称; -- 修改engine_test表的引擎为InnoDB ALTER TABLE engine_test ENGINE = INNODB; -- 查询engine_test表的引擎 SHOW TABLE STATUS FROM db11 WHERE NAME = 'engine_test'; 5.总结：引擎的选择 MyISAM ：由于MyISAM不支持事务、不支持外键、支持全文检索和表级锁定，读写相互阻塞，读取速度快，节约资源，所以如果应用是以查询操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 InnoDB : 是MySQL的默认存储引擎， 由于InnoDB支持事务、支持外键、行级锁定 ，支持所有辅助索引(5.5.5后不支持全文检索)，高缓存，所以用于对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，读写频繁的操作，那么InnoDB存储引擎是比较合适的选择，比如BBS、计费系统、充值转账等 MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供更快的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。 总结：针对不同的需求场景，来选择最适合的存储引擎即可！如果不确定、则使用数据库默认的存储引擎！ 二、MySQL索引 1.索引的概念 我们之前学习过集合，其中的ArrayList集合的特点之一就是有索引。那么有索引会带来哪些好处呢？ 没错，查询数据快！我们可以通过索引来快速查找到想要的数据。那么对于我们的MySQL数据库中的索引功能也是类似的！ MySQL数据库中的索引：是帮助MySQL高效获取数据的一种数据结构！所以，索引的本质就是数据结构。 在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。 一张数据表，用于保存数据。 一个索引配置文件，用于保存索引，每个索引都去指向了某一个数据(表格演示) 举例，无索引和有索引的查找原理 2.索引的分类 功能分类 普通索引： 最基本的索引，它没有任何限制。 唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值组合必须唯一。 主键索引：一种特殊的唯一索引，不允许有空值。一般在建表时同时创建主键索引。 组合索引：顾名思义，就是将单列索引进行组合。 外键索引：只有InnoDB引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作。 全文索引：快速匹配全部文档的方式。InnoDB引擎5.6版本后才支持全文索引。MEMORY引擎不支持。 结构分类 B+Tree索引 ：MySQL使用最频繁的一个索引数据结构，是InnoDB和MyISAM存储引擎默认的索引类型。 Hash索引 : MySQL中Memory存储引擎默认支持的索引类型。 3.索引的操作 数据准备 -- 创建db12数据库 CREATE DATABASE db12; -- 使用db12数据库 USE db12; -- 创建student表 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), age INT, score INT ); -- 添加数据 INSERT INTO student VALUES (NULL,'张三',23,98),(NULL,'李四',24,95), (NULL,'王五',25,96),(NULL,'赵六',26,94),(NULL,'周七',27,99); 创建索引 注意：如果一个表中有一列是主键，那么就会默认为其创建主键索引！(主键列不需要单独创建索引) -- 标准语法 CREATE [UNIQUE|FULLTEXT] INDEX 索引名称 [USING 索引类型] -- 默认是B+TREE ON 表名(列名...); -- 为student表中姓名列创建一个普通索引 CREATE INDEX idx_name ON student(NAME); -- 为student表中年龄列创建一个唯一索引 CREATE UNIQUE INDEX idx_age ON student(age); 查看索引 -- 标准语法 SHOW INDEX FROM 表名; -- 查看student表中的索引 SHOW INDEX FROM student; alter语句添加索引 -- 普通索引 ALTER TABLE 表名 ADD INDEX 索引名称(列名); -- 组合索引 ALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...); -- 主键索引 ALTER TABLE 表名 ADD PRIMARY KEY(主键列名); -- 外键索引(添加外键约束，就是外键索引) ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名); -- 唯一索引 ALTER TABLE 表名 ADD UNIQUE 索引名称(列名); -- 全文索引(mysql只支持文本类型) ALTER TABLE 表名 ADD FULLTEXT 索引名称(列名); -- 为student表中name列添加全文索引 ALTER TABLE student ADD FULLTEXT idx_fulltext_name(name); -- 查看student表中的索引 SHOW INDEX FROM student; 删除索引 -- 标准语法 DROP INDEX 索引名称 ON 表名; -- 删除student表中的idx_score索引 DROP INDEX idx_score ON student; -- 查看student表中的索引 SHOW INDEX FROM student; 4.索引效率的测试 -- 创建product商品表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, -- 商品id NAME VARCHAR(10), -- 商品名称 price INT -- 商品价格 ); -- 定义存储函数，生成长度为10的随机字符串并返回 DELIMITER $ CREATE FUNCTION rand_string() RETURNS VARCHAR(255) BEGIN DECLARE big_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ'; DECLARE small_str VARCHAR(255) DEFAULT ''; DECLARE i INT DEFAULT 1; WHILE i &lt;= 10 DO SET small_str =CONCAT(small_str,SUBSTRING(big_str,FLOOR(1+RAND()*52),1)); SET i=i+1; END WHILE; RETURN small_str; END$ DELIMITER ; -- 定义存储过程，添加100万条数据到product表中 DELIMITER $ CREATE PROCEDURE pro_test() BEGIN DECLARE num INT DEFAULT 1; WHILE num &lt;= 1000000 DO INSERT INTO product VALUES (NULL,rand_string(),num); SET num = num + 1; END WHILE; END$ DELIMITER ; -- 调用存储过程 CALL pro_test(); -- 查询总记录条数 SELECT COUNT(*) FROM product; -- 查询product表的索引 SHOW INDEX FROM product; -- 查询name为OkIKDLVwtG的数据 (0.049) SELECT * FROM product WHERE NAME='OkIKDLVwtG'; -- 通过id列查询OkIKDLVwtG的数据 (1毫秒) SELECT * FROM product WHERE id=999998; -- 为name列添加索引 ALTER TABLE product ADD INDEX idx_name(NAME); -- 查询name为OkIKDLVwtG的数据 (0.001) SELECT * FROM product WHERE NAME='OkIKDLVwtG'; /* 范围查询 */ -- 查询价格为800~1000之间的所有数据 (0.052) SELECT * FROM product WHERE price BETWEEN 800 AND 1000; /* 排序查询 */ -- 查询价格为800~1000之间的所有数据,降序排列 (0.083) SELECT * FROM product WHERE price BETWEEN 800 AND 1000 ORDER BY price DESC; -- 为price列添加索引 ALTER TABLE product ADD INDEX idx_price(price); -- 查询价格为800~1000之间的所有数据 (0.011) SELECT * FROM product WHERE price BETWEEN 800 AND 1000; -- 查询价格为800~1000之间的所有数据,降序排列 (0.001) SELECT * FROM product WHERE price BETWEEN 800 AND 1000 ORDER BY price DESC; 5.索引的实现原则 索引是在MySQL的存储引擎中实现的，所以每种存储引擎的索引不一定完全相同，也不是所有的引擎支持所有的索引类型。这里我们主要介绍InnoDB引擎的实现的B+Tree索引。 B+Tree是一种树型数据结构，是B-Tree的变种。通常使用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序。我们逐步的来了解一下。 5.1磁盘存储 系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的 位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。 InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB。 InnoDB引擎将若干个地址连接磁盘块，以此来达到页的大小16KB，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。 5.2BTree BTree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述BTree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。BTree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的BTree： 根据图中结构显示，每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。 查找顺序： 模拟查找15的过程 : 1.根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】 比较关键字15在区间（&lt;17），找到磁盘块1的指针P1。 2.P1指针找到磁盘块2，读入内存。【磁盘I/O操作第2次】 比较关键字15在区间（&gt;12），找到磁盘块2的指针P3。 3.P3指针找到磁盘块7，读入内存。【磁盘I/O操作第3次】 在磁盘块7中找到关键字15。 -- 分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。 -- 由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个BTree查找效率的决定因素。BTree使用较少的节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。 5.3B+Tree B+Tree是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。 从上一节中的BTree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。 B+Tree相对于BTree区别： 非叶子节点只存储键值信息。 所有叶子节点之间都有一个连接指针。 数据记录都存放在叶子节点中。 将上一节中的BTree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算： 【有范围】对于主键的范围查找和分页查找 【有顺序】从根节点开始，进行随机查找 实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在24层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要13次磁盘I/O操作。 6.总结：索引的设计原则 索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。 创建索引时的原则 对查询频次较高，且数据量比较大的表建立索引。 使用唯一索引，区分度越高，使用索引的效率越高。 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。 联合索引的特点 在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，对列name列、address和列phone列建一个联合索引 ALTER TABLE user ADD INDEX index_three(name,address,phone); 联合索引index_three实际建立了(name)、(name,address)、(name,address,phone)三个索引。所以下面的三个SQL语句都可以命中索引。 SELECT * FROM user WHERE address = '北京' AND phone = '12345' AND name = '张三'; SELECT * FROM user WHERE name = '张三' AND address = '北京'; SELECT * FROM user WHERE name = '张三'; 上面三个查询语句执行时会依照最左前缀匹配原则，检索时分别会使用索引 (name,address,phone) (name,address) (name) 进行数据匹配。 索引的字段可以是任意顺序的，如： -- 优化器会帮助我们调整顺序，下面的SQL语句都可以命中索引 SELECT * FROM user WHERE address = '北京' AND phone = '12345' AND name = '张三'; Mysql的优化器会帮助我们调整where条件中的顺序，以匹配我们建立的索引。 联合索引中最左边的列不包含在条件查询中，所以根据上面的原则，下面的SQL语句就不会命中索引。 -- 联合索引中最左边的列不包含在条件查询中，下面的SQL语句就不会命中索引 SELECT * FROM user WHERE address = '北京' AND phone = '12345'; 三、MySQL锁 1.锁的概念 之前我们学习过多线程，多线程当中如果想保证数据的准确性是如何实现的呢？没错，通过同步实现。同步就相当于是加锁。加了锁以后有什么好处呢？当一个线程真正在操作数据的时候，其他线程只能等待。当一个线程执行完毕后，释放锁。其他线程才能进行操作！ 那么我们的MySQL数据库中的锁的功能也是类似的。在我们学习事务的时候，讲解过事务的隔离性，可能会出现脏读、不可重复读、幻读的问题，当时我们的解决方式是通过修改事务的隔离级别来控制，但是数据库的隔离级别呢我们并不推荐修改。所以，锁的作用也可以解决掉之前的问题！ 锁机制 : 数据库为了保证数据的一致性，而使用各种共享的资源在被并发访问时变得有序所设计的一种规则。 举例，在电商网站购买商品时，商品表中只存有1个商品，而此时又有两个人同时购买，那么谁能买到就是一个关键的问题。 这里会用到事务进行一系列的操作： 先从商品表中取出物品的数据 然后插入订单 付款后，再插入付款表信息 更新商品表中商品的数量 以上过程中，使用锁可以对商品数量数据信息进行保护，实现隔离，即只允许第一位用户完成整套购买流程，而其他用户只能等待，这样就解决了并发中的矛盾问题。 在数据库中，数据是一种供许多用户共享访问的资源，如何保证数据并发访问的一致性、有效性，是所有数据库必须解决的一个问题，MySQL由于自身架构的特点，在不同的存储引擎中，都设计了面对特定场景的锁定机制，所以引擎的差别，导致锁机制也是有很大差别的。 2.锁的分类 按操作分类： 共享锁：也叫读锁。针对同一份数据，多个事务读取操作可以同时加锁而不互相影响 ，但是不能修改数据记录。 排他锁：也叫写锁。当前的操作没有完成前,会阻断其他操作的读取和写入 按粒度分类： 表级锁：操作时，会锁定整个表。开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低。偏向于MyISAM存储引擎！ 行级锁：操作时，会锁定当前操作行。开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。偏向于InnoDB存储引擎！ 页级锁：锁的粒度、发生冲突的概率和加锁的开销介于表锁和行锁之间，会出现死锁，并发性能一般。 按使用方式分类： 悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁。 乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据 不同存储引擎支持的锁 3.演示InnoDB锁 数据准备 -- 创建db13数据库 CREATE DATABASE db13; -- 使用db13数据库 USE db13; -- 创建student表 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), age INT, score INT ); -- 添加数据 INSERT INTO student VALUES (NULL,'张三',23,99),(NULL,'李四',24,95), (NULL,'王五',25,98),(NULL,'赵六',26,97); 共享锁 -- 标准语法 SELECT语句 LOCK IN SHARE MODE; -- 窗口1 /* 共享锁：数据可以被多个事务查询，但是不能修改 */ -- 开启事务 START TRANSACTION; -- 查询id为1的数据记录。加入共享锁 SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE; -- 查询分数为99分的数据记录。加入共享锁 SELECT * FROM student WHERE score=99 LOCK IN SHARE MODE; -- 提交事务 COMMIT; -- 窗口2 -- 开启事务 START TRANSACTION; -- 查询id为1的数据记录(普通查询，可以查询) SELECT * FROM student WHERE id=1; -- 查询id为1的数据记录，并加入共享锁(可以查询。共享锁和共享锁兼容) SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE; -- 修改id为1的姓名为张三三(不能修改，会出现锁的情况。只有窗口1提交事务后，才能修改成功) UPDATE student SET NAME='张三三' WHERE id = 1; -- 修改id为2的姓名为李四四(修改成功，InnoDB引擎默认是行锁) UPDATE student SET NAME='李四四' WHERE id = 2; -- 修改id为3的姓名为王五五(注意：InnoDB引擎如果不采用带索引的列。则会提升为表锁) UPDATE student SET NAME='王五五' WHERE id = 3; -- 提交事务 COMMIT; 排他锁 -- 标准语法 SELECT语句 FOR UPDATE; -- 窗口1 /* 排他锁：加锁的数据，不能被其他事务加锁查询或修改 */ -- 开启事务 START TRANSACTION; -- 查询id为1的数据记录，并加入排他锁 SELECT * FROM student WHERE id=1 FOR UPDATE; -- 提交事务 COMMIT; -- 窗口2 -- 开启事务 START TRANSACTION; -- 查询id为1的数据记录(普通查询没问题) SELECT * FROM student WHERE id=1; -- 查询id为1的数据记录，并加入共享锁(不能查询。因为排他锁不能和其他锁共存) SELECT * FROM student WHERE id=1 LOCK IN SHARE MODE; -- 查询id为1的数据记录，并加入排他锁(不能查询。因为排他锁不能和其他锁共存) SELECT * FROM student WHERE id=1 FOR UPDATE; -- 修改id为1的姓名为张三(不能修改，会出现锁的情况。只有窗口1提交事务后，才能修改成功) UPDATE student SET NAME='张三' WHERE id=1; -- 提交事务 COMMIT; 注意：锁的兼容性 共享锁和共享锁 兼容 共享锁和排他锁 冲突 排他锁和排他锁 冲突 排他锁和共享锁 冲突 4.演示MyISAM锁 数据准备 -- 创建product表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), price INT )ENGINE = MYISAM; -- 指定存储引擎为MyISAM -- 添加数据 INSERT INTO product VALUES (NULL,'华为手机',4999),(NULL,'小米手机',2999), (NULL,'苹果',8999),(NULL,'中兴',1999); 读锁 -- 标准语法 -- 加锁 LOCK TABLE 表名 READ; -- 解锁(将当前会话所有的表进行解锁) UNLOCK TABLES; -- 窗口1 /* 读锁：所有连接只能读取数据，不能修改 */ -- 为product表加入读锁 LOCK TABLE product READ; -- 查询product表(查询成功) SELECT * FROM product; -- 修改华为手机的价格为5999(修改失败) UPDATE product SET price=5999 WHERE id=1; -- 解锁 UNLOCK TABLES; -- 窗口2 -- 查询product表(查询成功) SELECT * FROM product; -- 修改华为手机的价格为5999(不能修改，窗口1解锁后才能修改成功) UPDATE product SET price=5999 WHERE id=1; 写锁 -- 标准语法 -- 加锁 LOCK TABLE 表名 WRITE; -- 解锁(将当前会话所有的表进行解锁) UNLOCK TABLES; -- 窗口1 /* 写锁：其他连接不能查询和修改数据 */ -- 为product表添加写锁 LOCK TABLE product WRITE; -- 查询product表(查询成功) SELECT * FROM product; -- 修改小米手机的金额为3999(修改成功) UPDATE product SET price=3999 WHERE id=2; -- 解锁 UNLOCK TABLES; -- 窗口2 -- 查询product表(不能查询。只有窗口1解锁后才能查询成功) SELECT * FROM product; -- 修改小米手机的金额为2999(不能修改。只有窗口1解锁后才能修改成功) UPDATE product SET price=2999 WHERE id=2; 5.演示悲观锁和乐观锁 悲观锁的概念 就是很悲观，它对于数据被外界修改的操作持保守态度，认为数据随时会修改。 整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系型数据库提供的锁机制。 我们之前所学的行锁，表锁不论是读写锁都是悲观锁。 乐观锁的概念 就是很乐观，每次自己操作数据的时候认为没有人会来修改它，所以不去加锁。 但是在更新的时候会去判断在此期间数据有没有被修改。 需要用户自己去实现，不会发生并发抢占资源，只有在提交操作的时候检查是否违反数据完整性。 悲观锁和乐观锁使用前提 对于读的操作远多于写的操作的时候，这时候一个更新操作加锁会阻塞所有的读取操作，降低了吞吐量。最后还要释放锁，锁是需要一些开销的，这时候可以选择乐观锁。 如果是读写比例差距不是非常大或者系统没有响应不及时，吞吐量瓶颈的问题，那就不要去使用乐观锁，它增加了复杂度，也带来了业务额外的风险。这时候可以选择悲观锁。 乐观锁的实现方式 版本号 给数据表中添加一个version列，每次更新后都将这个列的值加1。 读取数据时，将版本号读取出来，在执行更新的时候，比较版本号。 如果相同则执行更新，如果不相同，说明此条数据已经发生了变化。 用户自行根据这个通知来决定怎么处理，比如重新开始一遍，或者放弃本次更新。 时间戳 和版本号方式基本一样，给数据表中添加一个列，名称无所谓，数据类型需要是timestamp 每次更新后都将最新时间插入到此列。 读取数据时，将时间读取出来，在执行更新的时候，比较时间。 如果相同则执行更新，如果不相同，说明此条数据已经发生了变化。 6.锁的总结 表锁和行锁 行锁：锁的粒度更细，加行锁的性能损耗较大。并发处理能力较高。InnoDB引擎默认支持！ 表锁：锁的粒度较粗，加表锁的性能损耗较小。并发处理能力较低。InnoDB、MyISAM引擎支持！ InnoDB锁优化建议 尽量通过带索引的列来完成数据查询，从而避免InnoDB无法加行锁而升级为表锁。 合理设计索引，索引要尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定。 尽可能减少基于范围的数据检索过滤条件。 尽量控制事务的大小，减少锁定的资源量和锁定时间长度。 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁的产生。 四、集群 1.集群的概念 如今随着互联网的发展，数据的量级也是成指数的增长，从GB到TB到PB。对数据的各种操作也是愈加的困难，传统的关系型数据库已经无法满足快速查询与插入数据的需求。一台数据库服务器已经无法满足海量数据的存储需求，所以由多台数据库构成的数据库集群成了必然的方式。不过，为了保证数据的一致性，查询效率等，同时又要解决多台服务器间的通信、负载均衡等问题。 MyCat是一款数据库集群软件，是阿里曾经开源的知名产品——Cobar，简单的说，MyCAT就是：一个新颖的数据库中间件产品支持MySQL集群，提供高可用性数据分片集群。你可以像使用mysql一样使用mycat。对于开发人员来说根本感觉不到mycat的存在。MyCat不单单是支持MySQL，像常用的关系型数据库Oracle、SqlServer都支持。 2.集群的原理 我们来说个例子，大海捞针和一个水瓶里捞针，毋庸置疑水瓶里一定能更快找到针，因为它需要检索的范围更小。数据库集群也是如此原理，我们可以将一个数据量为300G的数据库数据平均拆分成3部分，每个数据库中只存储100G数据，此时用户搜索，先经过我们中间代理层，中间代理层同时发出3个请求执行查询，比如第1台返回100条数据，耗时3秒，第2台返回200条数据，耗时3秒，第3台返回500条数据，耗时3秒，此时中间件只需要在800条记录中进行筛选，即可检索出用户要的结果，此时耗时其实一共只有3秒，因为每台机器做运算的时候，都是同时执行。如果我们此时直接在300G的数据库查询，耗时10秒，那使用中间件进行集群的效率就非常明显 MyCat的实现流程和这个流程大致相似。MyCat自身不存储数据，但用户每次链接数据库的时候，直接连接MyCat即可.所以我们MyCat自身其实就是个逻辑数据库，它自身还有表结构，表结构叫逻辑表。 3.Mycat环境搭建 3.1 Mycat下载和安装 官网：http://www.mycat.io/ 下载地址 : http://dl.mycat.io/ 选择1.6.7.1的版本，下载到D盘，安装包入下图： 上传：使用SecureCRT的SFTP命令，将文件发送到Linux虚拟机root目录下： sftp&gt; put D:\\Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz 解压：解压mycat.tar.gz并查看 tar -zxvf mycat.tar.gz cd mycat ll 授权：设置mycat权限 chmod -R 777 mycat 环境变量：配置环境变量 vi /etc/profile // 添加 export MYCAT_HOME=/root/mycat // 使环境变量生效 source /etc/profile 启动mycat // 进入bin目录 [root@localhost]# cd /root/mycat/bin // 执行启动命令 [root@localhost bin]# ./mycat start 查看：检测端口监听状况，Mycat的端口号是8066 [root@localhost bin]# netstat -ant|grep 8066 连接：使用SQLYog连接Mycat 连接后显示： 3.2 环境准备 配置模型 克隆虚拟机 修改配置网卡 在第二个虚拟机中，生成全新mac地址 重启网络 // 重启网络 service network restart //查看ip地址 ip addr 修改mysql配置文件,更改uuid 在第二个服务器上，修改mysql的uuid // 编辑配置文件 vi /var/lib/mysql/auto.cnf // 将server-uuid更改 启动MySQL并查看 //将两台服务器的防火墙关闭 systemctl stop firewalld //启动两台服务器的mysql service mysqld restart //启动两台服务器的mycat cd /root/mycat/bin ./mycat restart //查看监听端口 netstat -ant|grep 3306 netstat -ant|grep 8066 //使用sqlyog测试连接 4.主从复制 主从复制的概念 为了使用Mycat进行读写分离，我们先要配置MySQL数据库的主从复制。 从服务器自动同步主服务器的数据，从而达到数据一致。 进而，我们可以写操作时，只操作主服务器，而读操作，就可以操作从服务器了。 原理：主服务器在处理数据时，生成binlog日志，通过对日志的备份，实现从服务器的数据同步。 主服务器的配置 在第一个服务器上，编辑mysql配置文件 // 编辑mysql配置文件 vi /etc/my.cnf //在[mysqld]下面加上： log-bin=mysql-bin # 开启复制操作 server-id=1 # master is 1 innodb_flush_log_at_trx_commit=1 sync_binlog=1 - 登录mysql，创建用户并授权 // 登录mysql mysql -u root -p // 去除密码权限 SET GLOBAL validate_password_policy=0; SET GLOBAL validate_password_length=1; // 创建用户 CREATE USER 'hm'@'%' IDENTIFIED BY 'itheima'; // 授权 GRANT ALL ON *.* TO 'hm'@'%'; - 重启mysql服务，登录mysql服务 // 重启mysql service mysqld restart // 登录mysql mysql -u root -p - 查看主服务器的配置 // 查看主服务器配置 show master status; 从服务器的配置 在第二个服务器上，编辑mysql配置文件 // 编辑mysql配置文件 vi /etc/my.cnf // 在[mysqld]下面加上： server-id=2 - 登录mysql // 登录mysql mysql -u root -p // 执行 use mysql; drop table slave_master_info; drop table slave_relay_log_info; drop table slave_worker_info; drop table innodb_index_stats; drop table innodb_table_stats; source /usr/share/mysql/mysql_system_tables.sql; - 重启mysql，重新登录，配置从节点 // 重启mysql service mysqld restart // 重新登录mysql mysql -u root -p // 执行 change master to master_host='主服务器ip地址',master_port=3306,master_user='hm',master_password='itheima',master_log_file='mysql-bin.000001',master_log_pos=4642; - 重启mysql，重新登录，开启从节点 // 重启mysql service mysqld restart // 重新登录mysql mysql -u root -p // 开启从节点 start slave; // 查询结果 show slave status\\G; //Slave_IO_Running和Slave_SQL_Running都为yes才表示同步成功。 测试 sqlyog连接主服务器 -- 主服务器创建db1数据库,从服务器会自动同步 CREATE DATABASE db1; - sqlyog连接从服务器 -- 从服务器创建db2数据库,主服务器不会自动同步 CREATE DATABASE db2; 启动失败的解决方案 启动失败：Slave_IO_Running为 NO 方法一:重置slave slave stop; reset slave; start slave ; 方法二:重设同步日志文件及读取位置 slave stop; change master to master_log_file=’mysql-bin.000001’, master_log_pos=1; start slave ; 5.读写分离 读写分离的概念 写操作只写入主服务器，读操作读取从服务器。 在主服务器上修改server.xml user标签主要用于定义登录mycat的用户和权限。如上面定义用户名mycat和密码123456，该用户可以访问的schema的HEIMADB逻辑库。 &lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt; &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt; &lt;property name=&quot;schemas&quot;&gt;HEIMADB&lt;/property&gt; &lt;!-- 表级 DML 权限设置 --&gt; &lt;!-- &lt;privileges check=&quot;false&quot;&gt; &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt; &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt; &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt; &lt;/schema&gt; &lt;/privileges&gt; --&gt; &lt;/user&gt; 在主服务器上修改schema.xml &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt; &lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt; &lt;schema name=&quot;HEIMADB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn1&quot;&gt;&lt;/schema&gt; &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;localhost1&quot; database=&quot;db1&quot; /&gt; &lt;dataHost name=&quot;localhost1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- 主服务器进行写操作 --&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;localhost:3306&quot; user=&quot;root&quot; password=&quot;itheima&quot;&gt; &lt;!-- 从服务器负责读操作 --&gt; &lt;readHost host=&quot;hostS1&quot; url=&quot;192.168.203.135:3306&quot; user=&quot;root&quot; password=&quot;itheima&quot; /&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; &lt;/mycat:schema&gt; 配置详解 schema标签逻辑库的概念和mysql数据库中Datebase的概念相同，我们在查询这两个逻辑库中的表的时候，需要切换到该逻辑库下才可以查到所需要的表。 dataNode属性：该属性用于绑定逻辑库到某个具体的database上。 dataNode标签： dataNode标签定义了mycat中的数据节点，也就是数据分片。一个dataNode标签就是一个独立的数据分片。 name属性：定义数据节点的名字，这个名字需要是唯一的，我们需要在table标签上应用这个名字，来建立表与分片对应的关系。 dataHost属性：该属性用于定义该分片属于那个数据库实例，属性值是引用datahost标签定义的name属性。 database属性：该属性用于定义该分片属于那个具体数据库实例上的具体库，因为这里使用两个纬度来定义分片，就是：实例+具体的库。因为每个库上建立的表和表结构是一样的。所以这样做就可以轻松的对表进行水平拆分。 dataHost标签：该标签在mycat逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分离配置和心跳语句。 balance属性： 负载均衡类型 balance=0: 不开启读写分离，所有读操作都发送到当前可用的writeHost上。 balance=1: 全部的readHost与Stand by writeHost都参与select语句的负载均衡 balance=2: 所有的读操作都随机在writeHost，readHost上分发。 balance=3: 所有的读请求都随机分配到writeHost对应的readHost上执行，writeHost不负担读压力。 switchType属性： -1：表示不自动切换。 1 ：默认值，表示自动切换 2：表示基于MySQL主从同步状态决定是否切换，心跳语句： show slave status. 3:表示基于mysql galary cluster的切换机制，适合mycat1.4之上的版本，心跳语句show status like &quot;%esrep%&quot;; writeHost标签，readHost标签：这两个标签指定后端数据库的相关配置给mycat，用于实例化后端连接池。唯一不同的是，writeHost指定写实例、readHost指定读实例，组合这些读写实例来满足系统的要求。 host属性：用于标识不同的实例，对于writehost，一般使用M1；对于readhost一般使用S1. url属性：后端实例连接地址，如果使用native的dbDriver，则一般为address:port这种形式，用JDBC或其他的dbDriver，则需要特殊指定。当使用JDBC时则可以这么写：jdbc:mysql://localhost:3306/。 user属性：后端存储实例的用户名。 password属性：后端存储实例的密码 测试 重启主服务器的mycat // 重启mycat cd /root/mycat/bin ./mycat restart // 查看端口监听 netstat -ant|grep 8066 - sqlyog连接mycat -- 创建学生表 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 查询学生表 SELECT * FROM student; -- 添加两条记录 INSERT INTO student VALUES (NULL,'张三'),(NULL,'李四'); -- 停止主从复制后，添加的数据只会保存到主服务器上。 INSERT INTO student VALUES (NULL,'王五'); - sqlyog连接主服务器 -- 主服务器：查询学生表，可以看到数据 SELECT * FROM student; - sqlyog连接从服务器 -- 从服务器：查询学生表，可以看到数据(因为有主从复制) SELECT * FROM student; -- 从服务器：删除一条记录。(主服务器并没有删除，mycat中间件查询的结果是从服务器的数据) DELETE FROM student WHERE id=2; 6.分库分表 分库分表的概念 将庞大的数据进行拆分 水平拆分：根据表的数据逻辑关系，将同一表中的数据按照某种条件，拆分到多台数据库服务器上，也叫做横向拆分。例如：一张1000万的大表，按照一模一样的结构，拆分成4个250万的小表，分别保存到4个数据库中。 垂直拆分：根据业务的维度，将不同的表切分到不同的数据库之上，也叫做纵向拆分。例如：所有的订单都保存到订单库中，所有的用户都保存到用户库中，同类型的表保存在同一库，不同的表分散在不同的库中。 Mycat水平拆分 修改主服务器的server.xml 0：本地文件方式 在mycat/conf/sequence_conf.properties文件中：GLOBAL.MINDI=10000最小值GLOBAL.MAXID=20000最大值，建议修改到9999999999 1：数据库方式 分库分表中保证全局主键自增唯一，但是需要执行mycat函数，配置sequence_db_conf.properties 2：时间戳方式 mycat实现的时间戳，建议varchar类型，要注意id的长度 &lt;!-- 修改主键的方式 --&gt; &lt;property name=&quot;sequnceHandlerType&quot;&gt;0&lt;/property&gt; - 修改主服务器的sequence_conf.properties #default global sequence GLOBAL.HISIDS= # 可以自定义关键字 GLOBAL.MINID=10001 # 最小值 GLOBAL.MAXID=20000 # 最大值 GLOBAL.CURID=10000 - 修改主服务器的schema.xml - table标签定义了逻辑表，所有需要拆分的表都需要在这个标签中定义。 - rule属性：拆分规则。mod-long是拆分规则之一，主键根据服务器数量取模，在rule.xml中指定。如果是3个数据库，那么数据取模后，平均分配到三个库中。 - name属性：定义逻辑表的表名，这个名字就如同在数据库中执行create table命令指定的名字一样，同一个schema标签中定义的表名必须是唯一的。 - dataNode属性： 定义这个逻辑表所属的dataNode，该属性的值需要和dataNode标签中name属性的值相互对应。 &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt; &lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt; &lt;schema name=&quot;HEIMADB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt; &lt;table name=&quot;product&quot; primaryKey=&quot;id&quot; dataNode=&quot;dn1,dn2,dn3&quot; rule=&quot;mod-long&quot;/&gt; &lt;/schema&gt; &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;localhost1&quot; database=&quot;db1&quot; /&gt; &lt;dataNode name=&quot;dn2&quot; dataHost=&quot;localhost1&quot; database=&quot;db2&quot; /&gt; &lt;dataNode name=&quot;dn3&quot; dataHost=&quot;localhost1&quot; database=&quot;db3&quot; /&gt; &lt;dataHost name=&quot;localhost1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- write --&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;localhost:3306&quot; user=&quot;root&quot; password=&quot;itheima&quot;&gt; &lt;!-- read --&gt; &lt;readHost host=&quot;hostS1&quot; url=&quot;192.168.203.135:3306&quot; user=&quot;root&quot; password=&quot;itheima&quot; /&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; &lt;/mycat:schema&gt; - 修改主服务器的rule.xml &lt;function name=&quot;mod-long&quot; class=&quot;io.mycat.route.function.PartitionByMod&quot;&gt; &lt;!-- 数据库的数量 --&gt; &lt;property name=&quot;count&quot;&gt;3&lt;/property&gt; &lt;/function&gt; 测试 - mycat操作 -- 创建product表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), price INT ); -- 添加6条数据 INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'苹果手机',6999); INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'华为手机',5999); INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'三星手机',4999); INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'小米手机',3999); INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'中兴手机',2999); INSERT INTO product(id,NAME,price) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'OOPO手机',1999); -- 查询product表 SELECT * FROM product; - 主服务器操作 -- 在不同数据库中查询product表 SELECT * FROM product; - 从服务器操作 -- 在不同数据库中查询product表 SELECT * FROM product; Mycat垂直拆分 修改主服务器的schema &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt; &lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt; &lt;schema name=&quot;HEIMADB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt; &lt;table name=&quot;product&quot; primaryKey=&quot;id&quot; dataNode=&quot;dn1,dn2,dn3&quot; rule=&quot;mod-long&quot;/&gt; &lt;!-- 动物类数据表 --&gt; &lt;table name=&quot;dog&quot; primaryKey=&quot;id&quot; autoIncrement=&quot;true&quot; dataNode=&quot;dn4&quot; /&gt; &lt;table name=&quot;cat&quot; primaryKey=&quot;id&quot; autoIncrement=&quot;true&quot; dataNode=&quot;dn4&quot; /&gt; &lt;!-- 水果类数据表 --&gt; &lt;table name=&quot;apple&quot; primaryKey=&quot;id&quot; autoIncrement=&quot;true&quot; dataNode=&quot;dn5&quot; /&gt; &lt;table name=&quot;banana&quot; primaryKey=&quot;id&quot; autoIncrement=&quot;true&quot; dataNode=&quot;dn5&quot; /&gt; &lt;/schema&gt; &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;localhost1&quot; database=&quot;db1&quot; /&gt; &lt;dataNode name=&quot;dn2&quot; dataHost=&quot;localhost1&quot; database=&quot;db2&quot; /&gt; &lt;dataNode name=&quot;dn3&quot; dataHost=&quot;localhost1&quot; database=&quot;db3&quot; /&gt; &lt;dataNode name=&quot;dn4&quot; dataHost=&quot;localhost1&quot; database=&quot;db4&quot; /&gt; &lt;dataNode name=&quot;dn5&quot; dataHost=&quot;localhost1&quot; database=&quot;db5&quot; /&gt; &lt;dataHost name=&quot;localhost1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- write --&gt; &lt;writeHost host=&quot;hostM1&quot; url=&quot;localhost:3306&quot; user=&quot;root&quot; password=&quot;itheima&quot;&gt; &lt;!-- read --&gt; &lt;readHost host=&quot;hostS1&quot; url=&quot;192.168.203.135:3306&quot; user=&quot;root&quot; password=&quot;itheima&quot; /&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; &lt;/mycat:schema&gt; 测试 - sqlyog连接mycat -- 创建dog表 CREATE TABLE dog( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO dog(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'哈士奇'); -- 查询dog表 SELECT * FROM dog; -- 创建cat表 CREATE TABLE cat( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO cat(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'波斯猫'); -- 查询cat表 SELECT * FROM cat; -- 创建apple表 CREATE TABLE apple( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO apple(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'红富士'); -- 查询apple表 SELECT * FROM apple; -- 创建banana表 CREATE TABLE banana( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO banana(id,NAME) VALUES (NEXT VALUE FOR MYCATSEQ_GLOBAL,'香蕉'); -- 查询banana表 SELECT * FROM banana; - sqlyog连接主服务器 -- 查询dog表 SELECT * FROM dog; -- 查询cat表 SELECT * FROM cat; -- 查询apple表 SELECT * FROM apple; -- 查询banana表 SELECT * FROM banana; - sqlyog连接从服务器 -- 查询dog表 SELECT * FROM dog; -- 查询cat表 SELECT * FROM cat; -- 查询apple表 SELECT * FROM apple; -- 查询banana表 SELECT * FROM banana; ","link":"https://gblw-blog.github.io/xEgqHEJL7/"},{"title":"Mysql-高级总结(1)","content":"一、MySQL存储过程和函数 1.存储过程和函数的概念 存储过程和函数是 事先经过编译并存储在数据库中的一段 SQL 语句的集合 2.存储过程和函数的好处 存储过程和函数可以重复使用，减轻开发人员的工作量。类似于java中方法可以多次调用 减少网络流量，存储过程和函数位于服务器上，调用的时候只需要传递名称和参数即可 减少数据在数据库和应用服务器之间的传输，可以提高数据处理的效率 将一些业务逻辑在数据库层面来实现，可以减少代码层面的业务处理 3.存储过程和函数的区别 函数必须有返回值 存储过程没有返回值 4.创建存储过程 小知识 /* 该关键字用来声明sql语句的分隔符，告诉MySQL该段命令已经结束！ sql语句默认的分隔符是分号，但是有的时候我们需要一条功能sql语句中包含分号，但是并不作为结束标识。 这个时候就可以使用DELIMITER来指定分隔符了！ */ -- 标准语法 DELIMITER 分隔符 数据准备 -- 创建db8数据库 CREATE DATABASE db8; -- 使用db8数据库 USE db8; -- 创建学生表 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, -- 学生id NAME VARCHAR(20), -- 学生姓名 age INT, -- 学生年龄 gender VARCHAR(5), -- 学生性别 score INT -- 学生成绩 ); -- 添加数据 INSERT INTO student VALUES (NULL,'张三',23,'男',95),(NULL,'李四',24,'男',98), (NULL,'王五',25,'女',100),(NULL,'赵六',26,'女',90); -- 按照性别进行分组，查询每组学生的总成绩。按照总成绩的升序排序 SELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC; 创建存储过程语法 -- 修改分隔符为$ DELIMITER $ -- 标准语法 CREATE PROCEDURE 存储过程名称(参数...) BEGIN sql语句; END$ -- 修改分隔符为分号 DELIMITER ; 创建存储过程 -- 修改分隔符为$ DELIMITER $ -- 创建存储过程，封装分组查询学生总成绩的sql语句 CREATE PROCEDURE stu_group() BEGIN SELECT gender,SUM(score) getSum FROM student GROUP BY gender ORDER BY getSum ASC; END$ -- 修改分隔符为分号 DELIMITER ; 5.调用存储过程 调用存储过程语法 -- 标准语法 CALL 存储过程名称(实际参数); -- 调用stu_group存储过程 CALL stu_group(); 6.查看存储过程 查看存储过程语法 -- 查询数据库中所有的存储过程 标准语法 SELECT * FROM mysql.proc WHERE db='数据库名称'; 7.删除存储过程 删除存储过程语法 -- 标准语法 DROP PROCEDURE [IF EXISTS] 存储过程名称; -- 删除stu_group存储过程 DROP PROCEDURE stu_group; 8.存储过程语法 8.1存储过程语法介绍 存储过程是可以进行编程的。意味着可以使用变量、表达式、条件控制语句、循环语句等，来完成比较复杂的功能！ 8.2变量的使用 定义变量 -- 标准语法 DECLARE 变量名 数据类型 [DEFAULT 默认值]; -- 注意： DECLARE定义的是局部变量，只能用在BEGIN END范围之内 -- 定义一个int类型变量、并赋默认值为10 DELIMITER $ CREATE PROCEDURE pro_test1() BEGIN DECLARE num INT DEFAULT 10; -- 定义变量 SELECT num; -- 查询变量 END$ DELIMITER ; -- 调用pro_test1存储过程 CALL pro_test1(); 变量的赋值1 -- 标准语法 SET 变量名 = 变量值; -- 定义字符串类型变量，并赋值 DELIMITER $ CREATE PROCEDURE pro_test2() BEGIN DECLARE NAME VARCHAR(10); -- 定义变量 SET NAME = '存储过程'; -- 为变量赋值 SELECT NAME; -- 查询变量 END$ DELIMITER ; -- 调用pro_test2存储过程 CALL pro_test2(); 变量的赋值2 -- 标准语法 SELECT 列名 INTO 变量名 FROM 表名 [WHERE 条件]; -- 定义两个int变量，用于存储男女同学的总分数 DELIMITER $ CREATE PROCEDURE pro_test3() BEGIN DECLARE men,women INT; -- 定义变量 SELECT SUM(score) INTO men FROM student WHERE gender='男'; -- 计算男同学总分数赋值给men SELECT SUM(score) INTO women FROM student WHERE gender='女'; -- 计算女同学总分数赋值给women SELECT men,women; -- 查询变量 END$ DELIMITER ; -- 调用pro_test3存储过程 CALL pro_test3(); 8.3if语句的使用 标准语法 -- 标准语法 IF 判断条件1 THEN 执行的sql语句1; [ELSEIF 判断条件2 THEN 执行的sql语句2;] ... [ELSE 执行的sql语句n;] END IF; 案例演示 /* 定义一个int变量，用于存储班级总成绩 定义一个varchar变量，用于存储分数描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般 */ DELIMITER $ CREATE PROCEDURE pro_test4() BEGIN -- 定义总分数变量 DECLARE total INT; -- 定义分数描述变量 DECLARE description VARCHAR(10); -- 为总分数变量赋值 SELECT SUM(score) INTO total FROM student; -- 判断总分数 IF total &gt;= 380 THEN SET description = '学习优秀'; ELSEIF total &gt;= 320 AND total &lt; 380 THEN SET description = '学习不错'; ELSE SET description = '学习一般'; END IF; -- 查询总成绩和描述信息 SELECT total,description; END$ DELIMITER ; -- 调用pro_test4存储过程 CALL pro_test4(); 8.4参数的传递 参数传递的语法 DELIMITER $ -- 标准语法 CREATE PROCEDURE 存储过程名称([IN|OUT|INOUT] 参数名 数据类型) BEGIN 执行的sql语句; END$ /* IN:代表输入参数，需要由调用者传递实际数据。默认的 OUT:代表输出参数，该参数可以作为返回值 INOUT:代表既可以作为输入参数，也可以作为输出参数 */ DELIMITER ; 输入参数 标准语法 DELIMITER $ -- 标准语法 CREATE PROCEDURE 存储过程名称(IN 参数名 数据类型) BEGIN 执行的sql语句; END$ DELIMITER ; - 案例演示 /* 输入总成绩变量，代表学生总成绩 定义一个varchar变量，用于存储分数描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般 */ DELIMITER $ CREATE PROCEDURE pro_test5(IN total INT) BEGIN -- 定义分数描述变量 DECLARE description VARCHAR(10); -- 判断总分数 IF total &gt;= 380 THEN SET description = '学习优秀'; ELSEIF total &gt;= 320 AND total &lt; 380 THEN SET description = '学习不错'; ELSE SET description = '学习一般'; END IF; -- 查询总成绩和描述信息 SELECT total,description; END$ DELIMITER ; -- 调用pro_test5存储过程 CALL pro_test5(390); CALL pro_test5((SELECT SUM(score) FROM student)); 输出参数 标准语法 DELIMITER $ -- 标准语法 CREATE PROCEDURE 存储过程名称(OUT 参数名 数据类型) BEGIN 执行的sql语句; END$ DELIMITER ; - 案例演示 /* 输入总成绩变量，代表学生总成绩 输出分数描述变量，代表学生总成绩的描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般 */ DELIMITER $ CREATE PROCEDURE pro_test6(IN total INT,OUT description VARCHAR(10)) BEGIN -- 判断总分数 IF total &gt;= 380 THEN SET description = '学习优秀'; ELSEIF total &gt;= 320 AND total &lt; 380 THEN SET description = '学习不错'; ELSE SET description = '学习一般'; END IF; END$ DELIMITER ; -- 调用pro_test6存储过程 CALL pro_test6(310,@description); -- 查询总成绩描述 SELECT @description; - 小知识 @变量名: 这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。 @@变量名: 这种在变量前加上 &quot;@@&quot; 符号, 叫做系统变量 8.5case语句的使用 标准语法1 -- 标准语法 CASE 表达式 WHEN 值1 THEN 执行sql语句1; [WHEN 值2 THEN 执行sql语句2;] ... [ELSE 执行sql语句n;] END CASE; 标准语法2 -- 标准语法 CASE WHEN 判断条件1 THEN 执行sql语句1; [WHEN 判断条件2 THEN 执行sql语句2;] ... [ELSE 执行sql语句n;] END CASE; 案例演示 /* 输入总成绩变量，代表学生总成绩 定义一个varchar变量，用于存储分数描述 根据总成绩判断： 380分及以上 学习优秀 320 ~ 380 学习不错 320以下 学习一般 */ DELIMITER $ CREATE PROCEDURE pro_test7(IN total INT) BEGIN -- 定义变量 DECLARE description VARCHAR(10); -- 使用case判断 CASE WHEN total &gt;= 380 THEN SET description = '学习优秀'; WHEN total &gt;= 320 AND total &lt; 380 THEN SET description = '学习不错'; ELSE SET description = '学习一般'; END CASE; -- 查询分数描述信息 SELECT description; END$ DELIMITER ; -- 调用pro_test7存储过程 CALL pro_test7(390); CALL pro_test7((SELECT SUM(score) FROM student)); 8.6while循环 标准语法 -- 标准语法 初始化语句; WHILE 条件判断语句 DO 循环体语句; 条件控制语句; END WHILE; 案例演示 /* 计算1~100之间的偶数和 */ DELIMITER $ CREATE PROCEDURE pro_test8() BEGIN -- 定义求和变量 DECLARE result INT DEFAULT 0; -- 定义初始化变量 DECLARE num INT DEFAULT 1; -- while循环 WHILE num &lt;= 100 DO -- 偶数判断 IF num%2=0 THEN SET result = result + num; -- 累加 END IF; -- 让num+1 SET num = num + 1; END WHILE; -- 查询求和结果 SELECT result; END$ DELIMITER ; -- 调用pro_test8存储过程 CALL pro_test8(); 8.7repeat循环 标准语法 -- 标准语法 初始化语句; REPEAT 循环体语句; 条件控制语句; UNTIL 条件判断语句 END REPEAT; -- 注意：repeat循环是条件满足则停止。while循环是条件满足则执行 案例演示 /* 计算1~10之间的和 */ DELIMITER $ CREATE PROCEDURE pro_test9() BEGIN -- 定义求和变量 DECLARE result INT DEFAULT 0; -- 定义初始化变量 DECLARE num INT DEFAULT 1; -- repeat循环 REPEAT -- 累加 SET result = result + num; -- 让num+1 SET num = num + 1; -- 停止循环 UNTIL num&gt;10 END REPEAT; -- 查询求和结果 SELECT result; END$ DELIMITER ; -- 调用pro_test9存储过程 CALL pro_test9(); 8.8loop循环 标准语法 -- 标准语法 初始化语句; [循环名称:] LOOP 条件判断语句 [LEAVE 循环名称;] 循环体语句; 条件控制语句; END LOOP 循环名称; -- 注意：loop可以实现简单的循环，但是退出循环需要使用其他的语句来定义。我们可以使用leave语句完成！ -- 如果不加退出循环的语句，那么就变成了死循环。 案例演示 /* 计算1~10之间的和 */ DELIMITER $ CREATE PROCEDURE pro_test10() BEGIN -- 定义求和变量 DECLARE result INT DEFAULT 0; -- 定义初始化变量 DECLARE num INT DEFAULT 1; -- loop循环 l:LOOP -- 条件成立，停止循环 IF num &gt; 10 THEN LEAVE l; END IF; -- 累加 SET result = result + num; -- 让num+1 SET num = num + 1; END LOOP l; -- 查询求和结果 SELECT result; END$ DELIMITER ; -- 调用pro_test10存储过程 CALL pro_test10(); 8.9游标 游标的概念 游标可以遍历返回的多行结果，每次拿到一整行数据 在存储过程和函数中可以使用游标对结果集进行循环的处理 简单来说游标就类似于集合的迭代器遍历 MySQL中的游标只能用在存储过程和函数中 游标的语法 创建游标 打开游标 使用游标获取数据 关闭游标 游标的基本使用 -- 创建stu_score表 CREATE TABLE stu_score( id INT PRIMARY KEY AUTO_INCREMENT, score INT ); /* 将student表中所有的成绩保存到stu_score表中 */ DELIMITER $ CREATE PROCEDURE pro_test11() BEGIN -- 定义成绩变量 DECLARE s_score INT; -- 创建游标,查询所有学生成绩数据 DECLARE stu_result CURSOR FOR SELECT score FROM student; -- 开启游标 OPEN stu_result; -- 使用游标，遍历结果,拿到第1行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第2行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第3行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第4行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 关闭游标 CLOSE stu_result; END$ DELIMITER ; -- 调用pro_test11存储过程 CALL pro_test11(); -- 查询stu_score表 SELECT * FROM stu_score; -- =========================================================== /* 出现的问题： student表中一共有4条数据，我们在游标遍历了4次，没有问题！ 但是在游标中多遍历几次呢？就会出现问题 */ DELIMITER $ CREATE PROCEDURE pro_test11() BEGIN -- 定义成绩变量 DECLARE s_score INT; -- 创建游标,查询所有学生成绩数据 DECLARE stu_result CURSOR FOR SELECT score FROM student; -- 开启游标 OPEN stu_result; -- 使用游标，遍历结果,拿到第1行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第2行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第3行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第4行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 使用游标，遍历结果,拿到第5行数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); -- 关闭游标 CLOSE stu_result; END$ DELIMITER ; -- 调用pro_test11存储过程 CALL pro_test11(); -- 查询stu_score表,虽然数据正确，但是在执行存储过程时会报错 SELECT * FROM stu_score; 游标的优化使用(配合循环使用) /* 当游标结束后，会触发游标结束事件。我们可以通过这一特性来完成循环操作 加标记思想： 1.定义一个变量，默认值为0(意味着有数据) 2.当游标结束后，将变量值改为1(意味着没有数据了) */ -- 1.定义一个变量，默认值为0(意味着有数据) DECLARE flag INT DEFAULT 0; -- 2.当游标结束后，将变量值改为1(意味着没有数据了) DECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1; /* 将student表中所有的成绩保存到stu_score表中 */ DELIMITER $ CREATE PROCEDURE pro_test12() BEGIN -- 定义成绩变量 DECLARE s_score INT; -- 定义标记变量 DECLARE flag INT DEFAULT 0; -- 创建游标，查询所有学生成绩数据 DECLARE stu_result CURSOR FOR SELECT score FROM student; -- 游标结束后，将标记变量改为1 DECLARE EXIT HANDLER FOR NOT FOUND SET flag = 1; -- 开启游标 OPEN stu_result; -- 循环使用游标 REPEAT -- 使用游标，遍历结果,拿到数据 FETCH stu_result INTO s_score; -- 将数据保存到stu_score表中 INSERT INTO stu_score VALUES (NULL,s_score); UNTIL flag=1 END REPEAT; -- 关闭游标 CLOSE stu_result; END$ DELIMITER ; -- 调用pro_test12存储过程 CALL pro_test12(); -- 查询stu_score表 SELECT * FROM stu_score; 9.存储过程的总结 存储过程是 事先经过编译并存储在数据库中的一段 SQL 语句的集合。可以在数据库层面做一些业务处理 说白了存储过程其实就是将sql语句封装为方法，然后可以调用方法执行sql语句而已 存储过程的好处 安全 高效 复用性强 10.存储函数 存储函数和存储过程是非常相似的。存储函数可以做的事情，存储过程也可以做到！ 存储函数有返回值，存储过程没有返回值(参数的out其实也相当于是返回数据了) 标准语法 创建存储函数 DELIMITER $ -- 标准语法 CREATE FUNCTION 函数名称([参数 数据类型]) RETURNS 返回值类型 BEGIN 执行的sql语句; RETURN 结果; END$ DELIMITER ; - 调用存储函数 -- 标准语法 SELECT 函数名称(实际参数); - 删除存储函数 -- 标准语法 DROP FUNCTION 函数名称; 案例演示 /* 定义存储函数，获取学生表中成绩大于95分的学生数量 */ DELIMITER $ CREATE FUNCTION fun_test1() RETURNS INT BEGIN -- 定义统计变量 DECLARE result INT; -- 查询成绩大于95分的学生数量，给统计变量赋值 SELECT COUNT(*) INTO result FROM student WHERE score &gt; 95; -- 返回统计结果 RETURN result; END$ DELIMITER ; -- 调用fun_test1存储函数 SELECT fun_test1(); 二、MySQL触发器 1.触发器的概念 触发器是与表有关的数据库对象，可以在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句。触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作 。 使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。 2.创建触发器 标准语法 DELIMITER $ CREATE TRIGGER 触发器名称 BEFORE|AFTER INSERT|UPDATE|DELETE ON 表名 [FOR EACH ROW] -- 行级触发器 BEGIN 触发器要执行的功能; END$ DELIMITER ; 触发器演示。通过触发器记录账户表的数据变更日志。包含：增加、修改、删除 创建账户表 -- 创建db9数据库 CREATE DATABASE db9; -- 使用db9数据库 USE db9; -- 创建账户表account CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, -- 账户id NAME VARCHAR(20), -- 姓名 money DOUBLE -- 余额 ); -- 添加数据 INSERT INTO account VALUES (NULL,'张三',1000),(NULL,'李四',2000); - 创建日志表 -- 创建日志表account_log - 创建INSERT触发器 -- 创建INSERT触发器 DELIMITER $ CREATE TRIGGER account_insert AFTER INSERT ON account FOR EACH ROW BEGIN INSERT INTO account_log VALUES (NULL,'INSERT',NOW(),new.id,CONCAT('插入后{id=',new.id,',name=',new.name,',money=',new.money,'}')); END$ DELIMITER ; -- 向account表添加记录 INSERT INTO account VALUES (NULL,'王五',3000); -- 查询account表 SELECT * FROM account; -- 查询日志表 SELECT * FROM account_log; - 创建UPDATE触发器 -- 创建UPDATE触发器 DELIMITER $ CREATE TRIGGER account_update AFTER UPDATE ON account FOR EACH ROW BEGIN INSERT INTO account_log VALUES (NULL,'UPDATE',NOW(),new.id,CONCAT('修改前{id=',old.id,',name=',old.name,',money=',old.money,'}','修改后{id=',new.id,',name=',new.name,',money=',new.money,'}')); END$ DELIMITER ; -- 修改account表 UPDATE account SET money=3500 WHERE id=3; -- 查询account表 SELECT * FROM account; -- 查询日志表 SELECT * FROM account_log; - 创建DELETE触发器 -- 创建DELETE触发器 DELIMITER $ CREATE TRIGGER account_delete AFTER DELETE ON account FOR EACH ROW BEGIN INSERT INTO account_log VALUES (NULL,'DELETE',NOW(),old.id,CONCAT('删除前{id=',old.id,',name=',old.name,',money=',old.money,'}')); END$ DELIMITER ; -- 删除account表数据 DELETE FROM account WHERE id=3; -- 查询account表 SELECT * FROM account; -- 查询日志表 SELECT * FROM account_log; 3.查看触发器 -- 标准语法 SHOW TRIGGERS; -- 查看触发器 SHOW TRIGGERS; 4.删除触发器 -- 标准语法 DROP TRIGGER 触发器名称; -- 删除DELETE触发器 DROP TRIGGER account_delete; 5.触发器的总结 触发器是与表有关的数据库对象 可以在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句 触发器的这种特性可以协助应用在数据库端确保数据的完整性 、日志记录 、数据校验等操作 使用别名 NEW 和 OLD 来引用触发器中发生变化的记录内容 三、MySQL事务 1.事务的概念 一条或多条 SQL 语句组成一个执行单元，其特点是这个单元要么同时成功要么同时失败，单元中的每条 SQL 语句都相互依赖，形成一个整体，如果某条 SQL 语句执行失败或者出现错误，那么整个单元就会回滚，撤回到事务最初的状态，如果单元中所有的 SQL 语句都执行成功，则事务就顺利执行。 2.事务的数据准备 -- 创建db10数据库 CREATE DATABASE db10; -- 使用db10数据库 USE db10; -- 创建账户表 CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, -- 账户id NAME VARCHAR(20), -- 账户名称 money DOUBLE -- 账户余额 ); -- 添加数据 INSERT INTO account VALUES (NULL,'张三',1000),(NULL,'李四',1000); 3.未管理事务演示 -- 张三给李四转账500元 -- 1.张三账户-500 UPDATE account SET money=money-500 WHERE NAME='张三'; -- 2.李四账户+500 出错了... UPDATE account SET money=money+500 WHERE NAME='李四'; -- 该场景下，这两条sql语句要么同时成功，要么同时失败。就需要被事务所管理！ 4.管理事务演示 操作事务的三个步骤 开启事务：记录回滚点，并通知服务器，将要执行一组操作，要么同时成功、要么同时失败 执行sql语句：执行具体的一条或多条sql语句 结束事务(提交|回滚) 提交：没出现问题，数据进行更新 回滚：出现问题，数据恢复到开启事务时的状态 开启事务 -- 标准语法 START TRANSACTION; 回滚事务 -- 标准语法 ROLLBACK; 提交事务 -- 标准语法 COMMIT; 管理事务演示 -- 开启事务 START TRANSACTION; -- 张三给李四转账500元 -- 1.张三账户-500 UPDATE account SET money=money-500 WHERE NAME='张三'; -- 2.李四账户+500 -- 出错了... UPDATE account SET money=money+500 WHERE NAME='李四'; -- 回滚事务(出现问题) ROLLBACK; -- 提交事务(没出现问题) COMMIT; 5.事务的提交方式 提交方式 自动提交(MySQL默认为自动提交) 手动提交 修改提交方式 查看提交方式 -- 标准语法 SELECT @@AUTOCOMMIT; -- 1代表自动提交 0代表手动提交 - 修改提交方式 -- 标准语法 SET @@AUTOCOMMIT=数字; -- 修改为手动提交 SET @@AUTOCOMMIT=0; -- 查看提交方式 SELECT @@AUTOCOMMIT; 6.事务的四大特征(ACID) 原子性(atomicity) 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响 一致性(consistency) 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态 拿转账来说，假设张三和李四两者的钱加起来一共是2000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是2000，这就是事务的一致性 隔离性(isolcation) 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离 持久性(durability) 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作 7.事务的隔离级别 隔离级别的概念 多个客户端操作时 ,各个客户端的事务之间应该是隔离的，相互独立的 , 不受影响的。 而如果多个事务操作同一批数据时，则需要设置不同的隔离级别 , 否则就会产生问题 。 我们先来了解一下四种隔离级别的名称 , 再来看看可能出现的问题 四种隔离级别 可能引发的问题 查询数据库隔离级别 -- 标准语法 SELECT @@TX_ISOLATION; 修改数据库隔离级别 -- 标准语法 SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串; -- 修改数据库隔离级别为read uncommitted SET GLOBAL TRANSACTION ISOLATION LEVEL read uncommitted; -- 查看隔离级别 SELECT @@TX_ISOLATION; -- 修改后需要断开连接重新开 8.事务隔离级别演示 脏读的问题 窗口1 -- 查询账户表 select * from account; -- 设置隔离级别为read uncommitted set global transaction isolation level read uncommitted; -- 开启事务 start transaction; -- 转账 update account set money = money - 500 where id = 1; update account set money = money + 500 where id = 2; -- 窗口2查询转账结果 ,出现脏读(查询到其他事务未提交的数据) -- 窗口2查看转账结果后，执行回滚 rollback; - 窗口2 -- 查询隔离级别 select @@tx_isolation; -- 开启事务 start transaction; -- 查询账户表 select * from account; 解决脏读的问题和演示不可重复读的问题 窗口1 -- 设置隔离级别为read committed set global transaction isolation level read committed; -- 开启事务 start transaction; -- 转账 update account set money = money - 500 where id = 1; update account set money = money + 500 where id = 2; -- 窗口2查看转账结果，并没有发生变化(脏读问题被解决了) -- 执行提交事务。 commit; -- 窗口2查看转账结果，数据发生了变化(出现了不可重复读的问题，读取到其他事务已提交的数据) - 窗口2 -- 查询隔离级别 select @@tx_isolation; -- 开启事务 start transaction; -- 查询账户表 select * from account; 解决不可重复读的问题 窗口1 -- 设置隔离级别为repeatable read set global transaction isolation level repeatable read; -- 开启事务 start transaction; -- 转账 update account set money = money - 500 where id = 1; update account set money = money + 500 where id = 2; -- 窗口2查看转账结果，并没有发生变化 -- 执行提交事务 commit; -- 这个时候窗口2只要还在上次事务中，看到的结果都是相同的。只有窗口2结束事务，才能看到变化(不可重复读的问题被解决) - 窗口2 -- 查询隔离级别 select @@tx_isolation; -- 开启事务 start transaction; -- 查询账户表 select * from account; -- 提交事务 commit; -- 查询账户表 select * from account; 幻读的问题和解决 窗口1 -- 设置隔离级别为repeatable read set global transaction isolation level repeatable read; -- 开启事务 start transaction; -- 添加一条记录 INSERT INTO account VALUES (3,'王五',1500); -- 查询账户表，本窗口可以查看到id为3的结果 SELECT * FROM account; -- 提交事务 COMMIT; - 窗口2 -- 查询隔离级别 select @@tx_isolation; -- 开启事务 start transaction; -- 查询账户表，查询不到新添加的id为3的记录 select * from account; -- 添加id为3的一条数据，发现添加失败。出现了幻读 INSERT INTO account VALUES (3,'测试',200); -- 提交事务 COMMIT; -- 查询账户表，查询到了新添加的id为3的记录 select * from account; - 解决幻读的问题 /* 窗口1 */ -- 设置隔离级别为serializable set global transaction isolation level serializable; -- 开启事务 start transaction; -- 添加一条记录 INSERT INTO account VALUES (4,'赵六',1600); -- 查询账户表，本窗口可以查看到id为4的结果 SELECT * FROM account; -- 提交事务 COMMIT; /* 窗口2 */ -- 查询隔离级别 select @@tx_isolation; -- 开启事务 start transaction; -- 查询账户表，发现查询语句无法执行，数据表被锁住！只有窗口1提交事务后，才可以继续操作 select * from account; -- 添加id为4的一条数据，发现已经存在了，就不会再添加了！幻读的问题被解决 INSERT INTO account VALUES (4,'测试',200); -- 提交事务 COMMIT; 9.隔离级别总结 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 , 所以不建议使用READ UNCOMMITTED 和 SERIALIZABLE 隔离级别. 10.事务的总结 一条或多条 SQL 语句组成一个执行单元，其特点是这个单元要么同时成功要么同时失败。例如转账操作 开启事务：start transaction; 回滚事务：rollback; 提交事务：commit; 事务四大特征 原子性 持久性 隔离性 一致性 事务的隔离级别 read uncommitted(读未提交) read committed (读已提交) repeatable read (可重复读) serializable (串行化) ","link":"https://gblw-blog.github.io/16u4WAcNn/"},{"title":"Mysql-基础总结","content":"SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL-操作数据库 - R(Retrieve)：查询 - 查询所有数据库 -- 查询所有数据库 SHOW DATABASES; - 查询某个数据库的创建语句 -- 标准语法 SHOW CREATE DATABASE 数据库名称; -- 查看mysql数据库的创建格式 SHOW CREATE DATABASE mysql; - C(Create)：创建 - 创建数据库 -- 标准语法 CREATE DATABASE 数据库名称; -- 创建db1数据库 CREATE DATABASE db1; -- 创建一个已存在的数据库会报错 -- 错误代码：1007 Can't create database 'db1'; database exists CREATE DATABASE db1; - 创建数据库(判断，如果不存在则创建) -- 标准语法 CREATE DATABASE IF NOT EXISTS 数据库名称; -- 创建数据库db2(判断，如果不存在则创建) CREATE DATABASE IF NOT EXISTS db2; - 创建数据库、并指定字符集 CREATE DATABASE 数据库名称 CHARACTER SET 字符集名称; -- 创建数据库db3、并指定字符集utf8 CREATE DATABASE db3 CHARACTER SET utf8; -- 查看db3数据库的字符集 SHOW CREATE DATABASE db3; - U(Update)：修改 - 修改数据库的字符集 -- 标准语法 ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称; -- 修改数据库db4的字符集为utf8 ALTER DATABASE db4 CHARACTER SET utf8; -- 查看db4数据库的字符集 SHOW CREATE DATABASE db4; - D(Delete)：删除 - 删除数据库 -- 标准语法 DROP DATABASE 数据库名称; -- 删除db1数据库 DROP DATABASE db1; -- 删除一个不存在的数据库会报错 -- 错误代码：1008 Can't drop database 'db1'; database doesn't exist DROP DATABASE db1; - 删除数据库(判断，如果存在则删除) -- 标准语法 DROP DATABASE IF EXISTS 数据库名称; -- 删除数据库db2，如果存在 DROP DATABASE IF EXISTS db2; - 使用数据库 - 查询当前正在使用的数据库名称 -- 查询当前正在使用的数据库 SELECT DATABASE(); - 使用数据库 -- 标准语法 USE 数据库名称； -- 使用db4数据库 USE db4; DDL-操作数据表 R(Retrieve)：查询 查询数据库中所有的数据表 -- 使用mysql数据库 USE mysql; -- 查询库中所有的表 SHOW TABLES; - 查询表结构 -- 标准语法 DESC 表名; -- 查询user表结构 DESC user; - 查询表字符集 -- 标准语法 SHOW TABLE STATUS FROM 库名 LIKE '表名'; -- 查看mysql数据库中user表字符集 SHOW TABLE STATUS FROM mysql LIKE 'user'; C(Create)：创建 创建数据表 标准语法 CREATE TABLE 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); -- 注意：最后一列，不需要加逗号 - 数据类型 1. int：整数类型 * age int 2. double:小数类型 * score double(5,2) * price double 3. date:日期，只包含年月日 yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间戳类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 - 创建数据表 -- 使用db3数据库 USE db3; -- 创建一个product商品表 CREATE TABLE product( id INT, -- 商品编号 NAME VARCHAR(30), -- 商品名称 price DOUBLE, -- 商品价格 stock INT, -- 商品库存 insert_time DATE -- 上架时间 ); - 复制表 -- 标准语法 CREATE TABLE 表名 LIKE 被复制的表名; -- 复制product表到product2表 CREATE TABLE product2 LIKE product; U(Update)：修改 修改表名 -- 标准语法 ALTER TABLE 表名 RENAME TO 新的表名; -- 修改product2表名为product3 ALTER TABLE product2 RENAME TO product3; - 修改表的字符集 -- 标准语法 ALTER TABLE 表名 CHARACTER SET 字符集名称; -- 查看db3数据库中product3数据表字符集 SHOW TABLE STATUS FROM db3 LIKE 'product3'; -- 修改product3数据表字符集为gbk ALTER TABLE product3 CHARACTER SET gbk; -- 查看db3数据库中product3数据表字符集 SHOW TABLE STATUS FROM db3 LIKE 'product3'; - 添加一列 -- 标准语法 ALTER TABLE 表名 ADD 列名 数据类型; -- 给product3表添加一列color ALTER TABLE product3 ADD color VARCHAR(10); - 修改列名称和数据类型 -- 修改数据类型 标准语法 ALTER TABLE 表名 MODIFY 列名 新数据类型; -- 将color数据类型修改为int ALTER TABLE product3 MODIFY color INT; -- 查看product3表详细信息 DESC product3; -- 修改列名和数据类型 标准语法 ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型; -- 将color修改为address,数据类型为varchar ALTER TABLE product3 CHANGE color address VARCHAR(30); -- 查看product3表详细信息 DESC product3; - 删除列 -- 标准语法 ALTER TABLE 表名 DROP 列名; -- 删除address列 ALTER TABLE product3 DROP address; D(Delete)：删除 删除数据表 -- 标准语法 DROP TABLE 表名; -- 删除product3表 DROP TABLE product3; -- 删除不存在的表，会报错 -- 错误代码：1051 Unknown table 'product3' DROP TABLE product3; - 删除数据表(判断，如果存在则删除) -- 标准语法 DROP TABLE IF EXISTS 表名; -- 删除product3表，如果存在则删除 DROP TABLE IF EXISTS product3; DML-INSERT语句 新增表数据语法 新增格式1：给指定列添加数据 -- 标准语法 INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...); -- 向product表添加一条数据 INSERT INTO product(id,NAME,price,stock,insert_time) VALUES (1,'手机',1999,22,'2099-09-09'); -- 向product表添加指定列数据 INSERT INTO product (id,NAME,price) VALUES (2,'电脑',4999); -- 查看表中所有数据 SELECT * FROM product; - 新增格式2：默认给全部列添加数据 -- 标准语法 INSERT INTO 表名 VALUES (值1,值2,值3,...); -- 默认给全部列添加数据 INSERT INTO product VALUES (3,'电视',2999,18,'2099-06-06'); -- 查看表中所有数据 SELECT * FROM product; - 新增格式3：批量添加数据 -- 默认添加所有列数据 标准语法 INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...); -- 批量添加数据 INSERT INTO product VALUES (4,'冰箱',999,26,'2099-08-08'),(5,'洗衣机',1999,32,'2099-05-10'); -- 查看表中所有数据 SELECT * FROM product; -- 给指定列添加数据 标准语法 INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...),(值1,值2,...),(值1,值2,...); -- 批量添加指定列数据 INSERT INTO product (id,NAME,price) VALUES (6,'微波炉',499),(7,'电磁炉',899); -- 查看表中所有数据 SELECT * FROM product; 注意事项 列名和值的数量以及数据类型要对应 除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引) DML-UPDATE语句 修改表数据语法 -- 标准语法 UPDATE 表名 SET 列名1 = 值1,列名2 = 值2,... [where 条件]; -- 修改手机的价格为3500 UPDATE product SET price=3500 WHERE NAME='手机'; -- 查看所有数据 SELECT * FROM product; -- 修改电视的价格为1800、库存为36 UPDATE product SET price=1800,stock=36 WHERE NAME='电视'; -- 修改电磁炉的库存为10 UPDATE product SET stock=10 WHERE id=7; 注意事项 修改语句中必须加条件 如果不加条件，则将所有数据都修改 DML-DELETE语句 删除表数据语法 -- 标准语法 DELETE FROM 表名 [WHERE 条件]; -- 删除product表中的微波炉信息 DELETE FROM product WHERE NAME='微波炉'; -- 删除product表中库存为10的商品信息 DELETE FROM product WHERE stock=10; -- 查看所有商品信息 SELECT * FROM product; 注意事项 删除语句中必须加条件 如果不加条件，则将所有数据删除 DQL-单表查询 数据准备(直接复制执行即可) -- 创建db1数据库 CREATE DATABASE db1; -- 使用db1数据库 USE db1; -- 创建数据表 CREATE TABLE product( id INT, -- 商品编号 NAME VARCHAR(20), -- 商品名称 price DOUBLE, -- 商品价格 brand VARCHAR(10), -- 商品品牌 stock INT, -- 商品库存 insert_time DATE -- 添加时间 ); -- 添加数据 INSERT INTO product VALUES (1,'华为手机',3999,'华为',23,'2088-03-10'), (2,'小米手机',2999,'小米',30,'2088-05-15'), (3,'苹果手机',5999,'苹果',18,'2088-08-20'), (4,'华为电脑',6999,'华为',14,'2088-06-16'), (5,'小米电脑',4999,'小米',26,'2088-07-08'), (6,'苹果电脑',8999,'苹果',15,'2088-10-25'), (7,'联想电脑',7999,'联想',NULL,'2088-11-11'); 查询语法 select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 查询全部 -- 标准语法 SELECT * FROM 表名; -- 查询product表所有数据 SELECT * FROM product; 查询部分 多个字段查询 -- 标准语法 SELECT 列名1,列名2,... FROM 表名; -- 查询名称、价格、品牌 SELECT NAME,price,brand FROM product; - 去除重复查询 - 注意：只有全部重复的才可以去除 -- 标准语法 SELECT DISTINCT 列名1,列名2,... FROM 表名; -- 查询品牌 SELECT brand FROM product; -- 查询品牌，去除重复 SELECT DISTINCT brand FROM product; - 计算列的值(四则运算) -- 标准语法 SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名; /* 计算列的值 标准语法： SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名; 如果某一列为null，可以进行替换 ifnull(表达式1,表达式2) 表达式1：想替换的列 表达式2：想替换的值 */ -- 查询商品名称和库存，库存数量在原有基础上加10 SELECT NAME,stock+10 FROM product; -- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断 SELECT NAME,IFNULL(stock,0)+10 FROM product; - 起别名 -- 标准语法 SELECT 列名1,列名2,... AS 别名 FROM 表名; -- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断。起别名为getSum SELECT NAME,IFNULL(stock,0)+10 AS getsum FROM product; SELECT NAME,IFNULL(stock,0)+10 getsum FROM product; 条件查询 条件分类 条件查询语法 -- 标准语法 SELECT 列名 FROM 表名 WHERE 条件; -- 查询库存大于20的商品信息 SELECT * FROM product WHERE stock &gt; 20; -- 查询品牌为华为的商品信息 SELECT * FROM product WHERE brand='华为'; -- 查询金额在4000 ~ 6000之间的商品信息 SELECT * FROM product WHERE price &gt;= 4000 AND price &lt;= 6000; SELECT * FROM product WHERE price BETWEEN 4000 AND 6000; -- 查询库存为14、30、23的商品信息 SELECT * FROM product WHERE stock=14 OR stock=30 OR stock=23; SELECT * FROM product WHERE stock IN(14,30,23); -- 查询库存为null的商品信息 SELECT * FROM product WHERE stock IS NULL; -- 查询库存不为null的商品信息 SELECT * FROM product WHERE stock IS NOT NULL; -- 查询名称以小米为开头的商品信息 SELECT * FROM product WHERE NAME LIKE '小米%'; -- 查询名称第二个字是为的商品信息 SELECT * FROM product WHERE NAME LIKE '_为%'; -- 查询名称为四个字符的商品信息 SELECT * FROM product WHERE NAME LIKE '____'; -- 查询名称中包含电脑的商品信息 SELECT * FROM product WHERE NAME LIKE '%电脑%'; 聚合函数 将一列数据作为一个整体，进行纵向的计算 聚合函数分类 聚合函数语法 -- 标准语法 SELECT 函数名(列名) FROM 表名 [WHERE 条件]; -- 计算product表中总记录条数 SELECT COUNT(*) FROM product; -- 获取最高价格 SELECT MAX(price) FROM product; -- 获取最高价格的商品名称 SELECT NAME,price FROM product WHERE price = (SELECT MAX(price) FROM product); -- 获取最低库存 SELECT MIN(stock) FROM product; -- 获取最低库存的商品名称 SELECT NAME,stock FROM product WHERE stock = (SELECT MIN(stock) FROM product); -- 获取总库存数量 SELECT SUM(stock) FROM product; -- 获取品牌为苹果的总库存数量 SELECT SUM(stock) FROM product WHERE brand='苹果'; -- 获取品牌为小米的平均商品价格 SELECT AVG(price) FROM product WHERE brand='小米'; 排序查询 排序分类 注意：多个排序条件，当前边的条件值一样时，才会判断第二条件 排序语法 -- 标准语法 SELECT 列名 FROM 表名 [WHERE 条件] ORDER BY 列名1 排序方式1,列名2 排序方式2; -- 按照库存升序排序 SELECT * FROM product ORDER BY stock ASC; -- 查询名称中包含手机的商品信息。按照金额降序排序 SELECT * FROM product WHERE NAME LIKE '%手机%' ORDER BY price DESC; -- 按照金额升序排序，如果金额相同，按照库存降序排列 SELECT * FROM product ORDER BY price ASC,stock DESC; 分组查询 -- 标准语法 SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式]; -- 按照品牌分组，获取每组商品的总金额 SELECT brand,SUM(price) FROM product GROUP BY brand; -- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额 SELECT brand,SUM(price) FROM product WHERE price &gt; 4000 GROUP BY brand; -- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的 SELECT brand,SUM(price) AS getSum FROM product WHERE price &gt; 4000 GROUP BY brand HAVING getSum &gt; 7000; -- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列 SELECT brand,SUM(price) AS getSum FROM product WHERE price &gt; 4000 GROUP BY brand HAVING getSum &gt; 7000 ORDER BY getSum DESC; 分页查询 -- 标准语法 SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式] LIMIT 开始索引,查询条数; -- 公式：开始索引 = (当前页码-1) * 每页显示的条数 -- 每页显示2条数据 SELECT * FROM product LIMIT 0,2; -- 第一页 开始索引=(1-1) * 2 SELECT * FROM product LIMIT 2,2; -- 第二页 开始索引=(2-1) * 2 SELECT * FROM product LIMIT 4,2; -- 第三页 开始索引=(3-1) * 2 SELECT * FROM product LIMIT 6,2; -- 第四页 开始索引=(4-1) * 2 分页查询图解 ","link":"https://gblw-blog.github.io/IcMsCwczO/"},{"title":"Mysql-进阶总结","content":"一、多表设计 1.一对一(了解) 分析 人和身份证。一个人只有一个身份证，一个身份证只能对应一个人！ 实现原则 在任意一个表建立外键，去关联另外一个表的主键 SQL演示 -- 创建db5数据库 CREATE DATABASE db5; -- 使用db5数据库 USE db5; -- 创建person表 CREATE TABLE person( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); -- 添加数据 INSERT INTO person VALUES (NULL,'张三'),(NULL,'李四'); -- 创建card表 CREATE TABLE card( id INT PRIMARY KEY AUTO_INCREMENT, number VARCHAR(50), pid INT UNIQUE, CONSTRAINT cp_fk1 FOREIGN KEY (pid) REFERENCES person(id) -- 添加外键 ); -- 添加数据 INSERT INTO card VALUES (NULL,'12345',1),(NULL,'56789',2); 图解 2.一对多 分析 用户和订单。一个用户可以有多个订单！ 商品分类和商品。一个分类下可以有多个商品！ 实现原则 在多的一方，建立外键约束，来关联一的一方主键 SQL演示 /* 用户和订单 */ -- 创建user表 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); -- 添加数据 INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四'); -- 创建orderlist表 CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, number VARCHAR(20), uid INT, CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) -- 添加外键约束 ); -- 添加数据 INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1),(NULL,'hm003',2),(NULL,'hm004',2); /* 商品分类和商品 */ -- 创建category表 CREATE TABLE category( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO category VALUES (NULL,'手机数码'),(NULL,'电脑办公'); -- 创建product表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30), cid INT, CONSTRAINT pc_fk1 FOREIGN KEY (cid) REFERENCES category(id) -- 添加外键约束 ); -- 添加数据 INSERT INTO product VALUES (NULL,'华为P30',1),(NULL,'小米note3',1), (NULL,'联想电脑',2),(NULL,'苹果电脑',2); 图解 3.多对多 分析 学生和课程。一个学生可以选择多个课程，一个课程也可以被多个学生选择！ 实现原则 需要借助第三张表中间表，中间表至少包含两个列，这两个列作为中间表的外键，分别关联两张表的主键 SQL演示 -- 创建student表 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); -- 添加数据 INSERT INTO student VALUES (NULL,'张三'),(NULL,'李四'); -- 创建course表 CREATE TABLE course( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10) ); -- 添加数据 INSERT INTO course VALUES (NULL,'语文'),(NULL,'数学'); -- 创建中间表 CREATE TABLE stu_course( id INT PRIMARY KEY AUTO_INCREMENT, sid INT, -- 用于和student表的id进行外键关联 cid INT, -- 用于和course表的id进行外键关联 CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), -- 添加外键约束 CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id) -- 添加外键约束 ); -- 添加数据 INSERT INTO stu_course VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2); 图解 二、多表查询 1.多表查询-数据准备 SQL语句 -- 创建db6数据库 CREATE DATABASE db6; -- 使用db6数据库 USE db6; -- 创建user表 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- 用户id NAME VARCHAR(20), -- 用户姓名 age INT -- 用户年龄 ); -- 添加数据 INSERT INTO USER VALUES (1,'张三',23); INSERT INTO USER VALUES (2,'李四',24); INSERT INTO USER VALUES (3,'王五',25); INSERT INTO USER VALUES (4,'赵六',26); -- 订单表 CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- 订单id number VARCHAR(30), -- 订单编号 uid INT, -- 外键字段 CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) ); -- 添加数据 INSERT INTO orderlist VALUES (1,'hm001',1); INSERT INTO orderlist VALUES (2,'hm002',1); INSERT INTO orderlist VALUES (3,'hm003',2); INSERT INTO orderlist VALUES (4,'hm004',2); INSERT INTO orderlist VALUES (5,'hm005',3); INSERT INTO orderlist VALUES (6,'hm006',3); INSERT INTO orderlist VALUES (7,'hm007',NULL); -- 商品分类表 CREATE TABLE category( id INT PRIMARY KEY AUTO_INCREMENT, -- 商品分类id NAME VARCHAR(10) -- 商品分类名称 ); -- 添加数据 INSERT INTO category VALUES (1,'手机数码'); INSERT INTO category VALUES (2,'电脑办公'); INSERT INTO category VALUES (3,'烟酒茶糖'); INSERT INTO category VALUES (4,'鞋靴箱包'); -- 商品表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, -- 商品id NAME VARCHAR(30), -- 商品名称 cid INT, -- 外键字段 CONSTRAINT cp_fk1 FOREIGN KEY (cid) REFERENCES category(id) ); -- 添加数据 INSERT INTO product VALUES (1,'华为手机',1); INSERT INTO product VALUES (2,'小米手机',1); INSERT INTO product VALUES (3,'联想电脑',2); INSERT INTO product VALUES (4,'苹果电脑',2); INSERT INTO product VALUES (5,'中华香烟',3); INSERT INTO product VALUES (6,'玉溪香烟',3); INSERT INTO product VALUES (7,'计生用品',NULL); -- 中间表 CREATE TABLE us_pro( upid INT PRIMARY KEY AUTO_INCREMENT, -- 中间表id uid INT, -- 外键字段。需要和用户表的主键产生关联 pid INT, -- 外键字段。需要和商品表的主键产生关联 CONSTRAINT up_fk1 FOREIGN KEY (uid) REFERENCES USER(id), CONSTRAINT up_fk2 FOREIGN KEY (pid) REFERENCES product(id) ); -- 添加数据 INSERT INTO us_pro VALUES (NULL,1,1); INSERT INTO us_pro VALUES (NULL,1,2); INSERT INTO us_pro VALUES (NULL,1,3); INSERT INTO us_pro VALUES (NULL,1,4); INSERT INTO us_pro VALUES (NULL,1,5); INSERT INTO us_pro VALUES (NULL,1,6); INSERT INTO us_pro VALUES (NULL,1,7); INSERT INTO us_pro VALUES (NULL,2,1); INSERT INTO us_pro VALUES (NULL,2,2); INSERT INTO us_pro VALUES (NULL,2,3); INSERT INTO us_pro VALUES (NULL,2,4); INSERT INTO us_pro VALUES (NULL,2,5); INSERT INTO us_pro VALUES (NULL,2,6); INSERT INTO us_pro VALUES (NULL,2,7); INSERT INTO us_pro VALUES (NULL,3,1); INSERT INTO us_pro VALUES (NULL,3,2); INSERT INTO us_pro VALUES (NULL,3,3); INSERT INTO us_pro VALUES (NULL,3,4); INSERT INTO us_pro VALUES (NULL,3,5); INSERT INTO us_pro VALUES (NULL,3,6); INSERT INTO us_pro VALUES (NULL,3,7); INSERT INTO us_pro VALUES (NULL,4,1); INSERT INTO us_pro VALUES (NULL,4,2); INSERT INTO us_pro VALUES (NULL,4,3); INSERT INTO us_pro VALUES (NULL,4,4); INSERT INTO us_pro VALUES (NULL,4,5); INSERT INTO us_pro VALUES (NULL,4,6); INSERT INTO us_pro VALUES (NULL,4,7); 2.多表查询-笛卡尔积查询(了解) 有两张表，获取这两个表的所有组合情况 要完成多表查询，需要消除这些没有用的数据 多表查询格式 SELECT 列名列表 FROM 表名列表 WHERE 条件... 笛卡尔积查询 -- 标准语法 SELECT 列名 FROM 表名1,表名2,...; -- 查询user表和orderlist表 SELECT * FROM USER,orderlist; 3.多表查询-内连接查询 查询原理 内连接查询的是两张表有交集的部分数据(有主外键关联的数据) 显式内连接 -- 标准语法 SELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 条件; -- 查询用户信息和对应的订单信息 SELECT * FROM USER INNER JOIN orderlist ON user.id=orderlist.uid; SELECT * FROM USER JOIN orderlist ON user.id=orderlist.uid; -- 查询用户信息和对应的订单信息，起别名 SELECT * FROM USER u JOIN orderlist o ON u.id=o.uid; -- 查询用户姓名，年龄。和订单编号 SELECT u.`name`, -- 姓名 u.`age`, -- 年龄 o.`number` -- 订单编号 FROM USER u -- 用户表 JOIN orderlist o -- 订单表 ON u.`id` = o.`uid`; 隐式内连接 -- 标准语法 SELECT 列名 FROM 表名1,表名2 WHERE 条件; -- 查询用户姓名，年龄。和订单编号 SELECT u.`name`, -- 姓名 u.`age`, -- 年龄 o.`number` -- 订单编号 FROM USER u, -- 用户表 orderlist o -- 订单表 WHERE u.`id`=o.`uid`; 4.多表查询-外连接查询 左外连接 查询原理 查询左表的全部数据，和左右两张表有交集部分的数据 基本演示 -- 标准语法 SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件; -- 查询所有用户信息，以及用户对应的订单信息 SELECT u.`name`, -- 姓名 u.`age`, -- 年龄 o.`number` -- 订单编号 FROM USER u -- 用户表 LEFT OUTER JOIN orderlist o -- 订单表 ON u.`id`=o.`uid`; 右外连接 查询原理 查询右表的全部数据，和左右两张表有交集部分的数据 基本演示 -- 基本语法 SELECT 列名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件; -- 查询所有订单信息，以及订单所属的用户信息 SELECT u.`name`, -- 姓名 u.`age`, -- 年龄 o.`number` -- 订单编号 FROM USER u -- 用户表 RIGHT OUTER JOIN orderlist o -- 订单表 ON u.`id`=o.`uid`; 5.多表查询-子查询 子查询介绍 查询语句中嵌套了查询语句。我们就将嵌套查询称为子查询！ 子查询-结果是单行单列的 可以作为条件，使用运算符进行判断！ 基本演示 -- 标准语法 SELECT 列名 FROM 表名 WHERE 列名=(SELECT 聚合函数(列名) FROM 表名 [WHERE 条件]); -- 查询年龄最高的用户姓名 SELECT MAX(age) FROM USER; -- 查询出最高年龄 SELECT NAME,age FROM USER WHERE age=26; -- 根据查询出来的最高年龄，查询姓名和年龄 SELECT NAME,age FROM USER WHERE age = (SELECT MAX(age) FROM USER); 子查询-结果是多行单列的 可以作为条件，使用运算符in或not in进行判断！ 基本演示 -- 标准语法 SELECT 列名 FROM 表名 WHERE 列名 [NOT] IN (SELECT 列名 FROM 表名 [WHERE 条件]); -- 查询张三和李四的订单信息 SELECT id FROM USER WHERE NAME='张三' OR NAME='李四'; -- 查询张三和李四用户的id SELECT number,uid FROM orderlist WHERE uid=1 OR uid=2; -- 根据id查询订单 SELECT number,uid FROM orderlist WHERE uid IN (SELECT id FROM USER WHERE NAME='张三' OR NAME='李四'); 子查询-结果是多行多列的 可以作为一张虚拟表参与查询！ 基本演示 -- 标准语法 SELECT 列名 FROM 表名 [别名],(SELECT 列名 FROM 表名 [WHERE 条件]) [别名] [WHERE 条件]; -- 查询订单表中id大于4的订单信息和所属用户信息 SELECT * FROM USER u,(SELECT * FROM orderlist WHERE id&gt;4) o WHERE u.id=o.uid; 6.多表查询练习 查询用户的编号、姓名、年龄。订单编号 /* 分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 FROM USER t1, -- 用户表 orderlist t2 -- 订单表 WHERE t1.`id` = t2.`uid`; 查询所有的用户。用户的编号、姓名、年龄。订单编号 /* 分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid 查询所有用户，使用左外连接 */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 FROM USER t1 -- 用户表 LEFT OUTER JOIN orderlist t2 -- 订单表 ON t1.`id` = t2.`uid`; 查询所有的订单。用户的编号、姓名、年龄。订单编号 /* 分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid 查询所有订单，使用右外连接 */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 FROM USER t1 -- 用户表 RIGHT OUTER JOIN orderlist t2 -- 订单表 ON t1.`id` = t2.`uid`; 查询用户年龄大于23岁的信息。显示用户的编号、姓名、年龄。订单编号 /* 分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.age &gt; 23 AND user.id = orderlist.uid */ /* select t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 from user t1, -- 用户表 orderlist t2 -- 订单表 where t1.`age` &gt; 23 and t1.`id` = t2.`uid`; */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 FROM USER t1 -- 用户表 LEFT OUTER JOIN orderlist t2 -- 订单表 ON t1.`id` = t2.`uid` WHERE t1.`age` &gt; 23; 查询张三和李四用户的信息。显示用户的编号、姓名、年龄。订单编号 /* 分析： 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id = orderlist.uid AND user.name IN ('张三','李四'); */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户姓名 t1.`age`, -- 用户年龄 t2.`number` -- 订单编号 FROM USER t1, -- 用户表 orderlist t2 -- 订单表 WHERE t1.`id` = t2.`uid` AND -- (t1.`name` = '张三' OR t1.`name` = '李四'); t1.`name` IN ('张三','李四'); 查询商品分类的编号、分类名称。分类下的商品名称 /* 分析： 商品分类的编号、分类名称 category表 分类下的商品名称 product表 条件：category.id = product.cid */ SELECT t1.`id`, -- 分类编号 t1.`name`, -- 分类名称 t2.`name` -- 商品名称 FROM category t1, -- 商品分类表 product t2 -- 商品表 WHERE t1.`id` = t2.`cid`; 查询所有的商品分类。商品分类的编号、分类名称。分类下的商品名称 /* 分析： 商品分类的编号、分类名称 category表 分类下的商品名称 product表 条件：category.id = product.cid 查询所有的商品分类，使用左外连接 */ SELECT t1.`id`, -- 分类编号 t1.`name`, -- 分类名称 t2.`name` -- 商品名称 FROM category t1 -- 商品分类表 LEFT OUTER JOIN product t2 -- 商品表 ON t1.`id` = t2.`cid`; 查询所有的商品信息。商品分类的编号、分类名称。分类下的商品名称 /* 分析： 商品分类的编号、分类名称 category表 分类下的商品名称 product表 条件：category.id = product.cid 查询所有的商品信息，使用右外连接 */ SELECT t1.`id`, -- 分类编号 t1.`name`, -- 分类名称 t2.`name` -- 商品名称 FROM category t1 -- 商品分类表 RIGHT OUTER JOIN product t2 -- 商品表 ON t1.`id` = t2.`cid`; 查询所有的用户和所有的商品。显示用户的编号、姓名、年龄。商品名称 /* 分析： 用户的编号、姓名、年龄 user表 商品名称 product表 中间表 us_pro 条件：us_pro.uid = user.id AND us_pro.pid = product.id */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户名称 t1.`age`, -- 用户年龄 t2.`name` -- 商品名称 FROM USER t1, -- 用户表 product t2, -- 商品表 us_pro t3 -- 中间表 WHERE t3.`uid` = t1.`id` AND t3.`pid` = t2.`id`; 查询张三和李四这两个用户可以看到的商品。显示用户的编号、姓名、年龄。商品名称 /* 分析： 用户的编号、姓名、年龄 user表 商品名称 product表 中间表 us_pro 条件：us_pro.uid = user.id AND us_pro.pid = product.id AND user.name IN ('张三','李四') */ SELECT t1.`id`, -- 用户编号 t1.`name`, -- 用户名称 t1.`age`, -- 用户年龄 t2.`name` -- 商品名称 FROM USER t1, -- 用户表 product t2, -- 商品表 us_pro t3 -- 中间表 WHERE (t3.`uid` = t1.`id` AND t3.`pid` = t2.`id`) AND -- (t1.`name` = '张三' or t1.`name` = '李四'); t1.`name` IN ('张三','李四'); 7.多表查询-自关联查询 自关联查询介绍 同一张表中有数据关联。可以多次查询这同一个表！ 自关联查询演示 -- 创建员工表 CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), mgr INT, salary DOUBLE ); -- 添加数据 INSERT INTO employee VALUES (1001,'孙悟空',1005,9000.00), (1002,'猪八戒',1005,8000.00), (1003,'沙和尚',1005,8500.00), (1004,'小白龙',1005,7900.00), (1005,'唐僧',NULL,15000.00), (1006,'武松',1009,7600.00), (1007,'李逵',1009,7400.00), (1008,'林冲',1009,8100.00), (1009,'宋江',NULL,16000.00); -- 查询所有员工的姓名及其直接上级的姓名，没有上级的员工也需要查询 /* 分析： 员工姓名 employee表 直接上级姓名 employee表 条件：employee.mgr = employee.id 查询左表的全部数据，和左右两张表交集部分数据，使用左外连接 */ SELECT t1.name, -- 员工姓名 t1.mgr, -- 上级编号 t2.id, -- 员工编号 t2.name -- 员工姓名 FROM employee t1 -- 员工表 LEFT OUTER JOIN employee t2 -- 员工表 ON t1.mgr = t2.id; 三、视图 1.视图的概念 视图是一种虚拟存在的数据表 这个虚拟的表并不在数据库中实际存在 作用是将一些比较复杂的查询语句的结果，封装到一个虚拟表中。后期再有相同复杂查询时，直接查询这张虚拟表即可 说白了，视图就是将一条SELECT查询语句的结果封装到了一个虚拟表中，所以我们在创建视图的时候，工作重心就要放在这条SELECT查询语句上 2.视图的好处 简单 对于使用视图的用户不需要关心表的结构、关联条件和筛选条件。因为这张虚拟表中保存的就是已经过滤好条件的结果集 安全 视图可以设置权限 , 致使访问视图的用户只能访问他们被允许查询的结果集 数据独立 一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响 3.视图数据准备 -- 创建db7数据库 CREATE DATABASE db7; -- 使用db7数据库 USE db7; -- 创建country表 CREATE TABLE country( id INT PRIMARY KEY AUTO_INCREMENT, country_name VARCHAR(30) ); -- 添加数据 INSERT INTO country VALUES (NULL,'中国'),(NULL,'美国'),(NULL,'俄罗斯'); -- 创建city表 CREATE TABLE city( id INT PRIMARY KEY AUTO_INCREMENT, city_name VARCHAR(30), cid INT, -- 外键列。关联country表的主键列id CONSTRAINT cc_fk1 FOREIGN KEY (cid) REFERENCES country(id) ); -- 添加数据 INSERT INTO city VALUES (NULL,'北京',1),(NULL,'上海',1),(NULL,'纽约',2),(NULL,'莫斯科',3); 4.视图的创建 创建视图语法 -- 标准语法 CREATE VIEW 视图名称 [(列名列表)] AS 查询语句; 普通多表查询，查询城市和所属国家 -- 普通多表查询，查询城市和所属国家 SELECT t1.*, t2.country_name FROM city t1, country t2 WHERE t1.cid = t2.id; -- 经常需要查询这样的数据，就可以创建一个视图 创建视图基本演示 -- 创建一个视图。将查询出来的结果保存到这张虚拟表中 CREATE VIEW city_country AS SELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id; 创建视图并指定列名基本演示 -- 创建一个视图，指定列名。将查询出来的结果保存到这张虚拟表中 CREATE VIEW city_country2 (city_id,city_name,cid,country_name) AS SELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id; 5.视图的查询 查询视图语法 -- 标准语法 SELECT * FROM 视图名称; 查询视图基本演示 -- 查询视图。查询这张虚拟表，就等效于查询城市和所属国家 SELECT * FROM city_country; -- 查询指定列名的视图 SELECT * FROM city_country2; -- 查询所有数据表，视图也会查询出来 SHOW TABLES; 查询视图创建语法 -- 标准语法 SHOW CREATE VIEW 视图名称; 查询视图创建语句基本演示 SHOW CREATE VIEW city_country; 6.视图的修改 修改视图表中的数据 -- 标准语法 UPDATE 视图名称 SET 列名=值 WHERE 条件; -- 修改视图表中的城市名称北京为北京市 UPDATE city_country SET city_name='北京市' WHERE city_name='北京'; -- 查询视图 SELECT * FROM city_country; -- 查询city表,北京也修改为了北京市 SELECT * FROM city; -- 注意：视图表数据修改，会自动修改源表中的数据 修改视图表结构 -- 标准语法 ALTER VIEW 视图名称 [(列名列表)] AS 查询语句; -- 查询视图2 SELECT * FROM city_country2; -- 修改视图2的列名city_id为id ALTER VIEW city_country2 (id,city_name,cid,country_name) AS SELECT t1.*,t2.country_name FROM city t1,country t2 WHERE t1.cid=t2.id; 7.视图的删除 删除视图 -- 标准语法 DROP VIEW [IF EXISTS] 视图名称; -- 删除视图 DROP VIEW city_country; -- 删除视图2，如果存在则删除 DROP VIEW IF EXISTS city_country2; 8.视图的总结 视图是一种虚拟存在的数据表 这个虚拟的表并不在数据库中实际存在 说白了，视图就是将一条SELECT查询语句的结果封装到了一个虚拟表中，所以我们在创建视图的时候，工作重心就要放在这条SELECT查询语句上 视图的好处 简单 安全 数据独立 ","link":"https://gblw-blog.github.io/6Nas0HqUb/"},{"title":"Mysql-约束相关","content":" 约束的概念和分类 约束的概念 对表中的数据进行限定，保证数据的正确性、有效性、完整性！ 约束的分类 PRIMARY KEY---&gt;主键约束 PRIMARY KEY AUTO_INCREMENT---&gt;主键、自动增长 UNIQUE---&gt;唯一约束 NOT NULL---&gt;非空约束 FOREIGN KEY---&gt;外键约束 FOREIGN KEY ON UPDATE CASCADE---&gt;外键级联更新 FOREIGN KEY ON DELETE CASCADE---&gt;外键级联删除 主键约束 主键约束特点 主键约束包含：非空和唯一两个功能 一张表只能有一个列作为主键 主键一般用于表中数据的唯一标识 建表时添加主键约束 -- 标准语法 CREATE TABLE 表名( 列名 数据类型 PRIMARY KEY, 列名 数据类型, ... ); -- 创建student表 CREATE TABLE student( id INT PRIMARY KEY -- 给id添加主键约束 ); -- 添加数据 INSERT INTO student VALUES (1),(2); -- 主键默认唯一，添加重复数据，会报错 INSERT INTO student VALUES (2); -- 主键默认非空，不能添加null的数据 INSERT INTO student VALUES (NULL); -- 查询student表 SELECT * FROM student; -- 查询student表详细 DESC student; 删除主键 -- 标准语法 ALTER TABLE 表名 DROP PRIMARY KEY; -- 删除主键 ALTER TABLE student DROP PRIMARY KEY; 建表后单独添加主键 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型 PRIMARY KEY; -- 添加主键 ALTER TABLE student MODIFY id INT PRIMARY KEY; 主键自动增长约束 建表时添加主键自增约束 -- 标准语法 CREATE TABLE 表名( 列名 数据类型 PRIMARY KEY AUTO_INCREMENT, 列名 数据类型, ... ); -- 创建student2表 CREATE TABLE student2( id INT PRIMARY KEY AUTO_INCREMENT -- 给id添加主键自增约束 ); -- 添加数据 INSERT INTO student2 VALUES (1),(2); -- 添加null值，会自动增长 INSERT INTO student2 VALUES (NULL),(NULL); -- 查询student2表 SELECT * FROM student2; -- student2表详细 DESC student2; 删除自动增长 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型; -- 删除自动增长 ALTER TABLE student2 MODIFY id INT; 建表后单独添加自动增长 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型 AUTO_INCREMENT; -- 添加自动增长 ALTER TABLE student2 MODIFY id INT AUTO_INCREMENT; 唯一约束 建表时添加唯一约束 -- 标准语法 CREATE TABLE 表名( 列名 数据类型 UNIQUE, 列名 数据类型, ... ); -- 创建student3表 CREATE TABLE student3( id INT PRIMARY KEY AUTO_INCREMENT, tel VARCHAR(20) UNIQUE -- 给tel列添加唯一约束 ); -- 添加数据 INSERT INTO student3 VALUES (NULL,'18888888888'),(NULL,'18666666666'); -- 添加重复数据，会报错 INSERT INTO student3 VALUES (NULL,'18666666666'); -- 查询student3数据表 SELECT * FROM student3; -- student3表详细 DESC student3; 删除唯一约束 -- 标准语法 ALTER TABLE 表名 DROP INDEX 列名; -- 删除唯一约束 ALTER TABLE student3 DROP INDEX tel; 建表后单独添加唯一约束 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型 UNIQUE; -- 添加唯一约束 ALTER TABLE student3 MODIFY tel VARCHAR(20) UNIQUE; 非空约束 建表时添加非空约束 -- 标准语法 CREATE TABLE 表名( 列名 数据类型 NOT NULL, 列名 数据类型, ... ); -- 创建student4表 CREATE TABLE student4( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) NOT NULL -- 给name添加非空约束 ); -- 添加数据 INSERT INTO student4 VALUES (NULL,'张三'),(NULL,'李四'); -- 添加null值，会报错 INSERT INTO student4 VALUES (NULL,NULL); 删除非空约束 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型; -- 删除非空约束 ALTER TABLE student4 MODIFY NAME VARCHAR(20); 建表后单独添加非空约束 -- 标准语法 ALTER TABLE 表名 MODIFY 列名 数据类型 NOT NULL; -- 添加非空约束 ALTER TABLE student4 MODIFY NAME VARCHAR(20) NOT NULL; 外键约束 外键约束概念 让表和表之间产生关系，从而保证数据的准确性！ 建表时添加外键约束 为什么要有外键约束 -- 创建db2数据库 CREATE DATABASE db2; -- 使用db2数据库 USE db2; -- 创建user用户表 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- id NAME VARCHAR(20) NOT NULL -- 姓名 ); -- 添加用户数据 INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四'),(NULL,'王五'); -- 创建orderlist订单表 CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- id number VARCHAR(20) NOT NULL, -- 订单编号 uid INT -- 订单所属用户 ); -- 添加订单数据 INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1), (NULL,'hm003',2),(NULL,'hm004',2), (NULL,'hm005',3),(NULL,'hm006',3); -- 添加一个订单，但是没有所属用户。这合理吗？ INSERT INTO orderlist VALUES (NULL,'hm007',8); -- 删除王五这个用户，但是订单表中王五还有很多个订单呢。这合理吗？ DELETE FROM USER WHERE NAME='王五'; -- 所以我们需要添加外键约束，让两张表产生关系 外键约束格式 CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) 创建表添加外键约束 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- id NAME VARCHAR(20) NOT NULL -- 姓名 ); -- 添加用户数据 INSERT INTO USER VALUES (NULL,'张三'),(NULL,'李四'),(NULL,'王五'); -- 创建orderlist订单表 CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- id number VARCHAR(20) NOT NULL, -- 订单编号 uid INT, -- 订单所属用户 CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) -- 添加外键约束 ); -- 添加订单数据 INSERT INTO orderlist VALUES (NULL,'hm001',1),(NULL,'hm002',1), (NULL,'hm003',2),(NULL,'hm004',2), (NULL,'hm005',3),(NULL,'hm006',3); -- 添加一个订单，但是没有所属用户。无法添加 INSERT INTO orderlist VALUES (NULL,'hm007',8); -- 删除王五这个用户，但是订单表中王五还有很多个订单呢。无法删除 DELETE FROM USER WHERE NAME='王五'; 删除外键约束 -- 标准语法 ALTER TABLE 表名 DROP FOREIGN KEY 外键名; -- 删除外键 ALTER TABLE orderlist DROP FOREIGN KEY ou_fk1; 建表后添加外键约束 -- 标准语法 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名); -- 添加外键约束 ALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id); 外键的级联更新和级联删除(了解) 什么是级联更新和级联删除 当我想把user用户表中的某个用户删掉，我希望该用户所有的订单也随之被删除 当我想把user用户表中的某个用户id修改，我希望订单表中该用户所属的订单用户编号也随之修改 添加级联更新和级联删除 -- 添加外键约束，同时添加级联更新 标准语法 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON UPDATE CASCADE; -- 添加外键约束，同时添加级联删除 标准语法 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON DELETE CASCADE; -- 添加外键约束，同时添加级联更新和级联删除 标准语法 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON UPDATE CASCADE ON DELETE CASCADE; -- 删除外键约束 ALTER TABLE orderlist DROP FOREIGN KEY ou_fk1; -- 添加外键约束，同时添加级联更新和级联删除 ALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) ON UPDATE CASCADE ON DELETE CASCADE; -- 将王五用户的id修改为5 订单表中的uid也随之被修改 UPDATE USER SET id=5 WHERE id=3; -- 将王五用户删除 订单表中该用户所有订单也随之删除 DELETE FROM USER WHERE id=5; ","link":"https://gblw-blog.github.io/8IYINWEAB/"},{"title":"Linux常用命令整理","content":" 文件处理命令 mkdir: 创建目录 -p : 递归的创建目录 也就是可以创建多层目录 一次创建多个目录： mkdir {a,b,c,d,e,f} 一次创建 a b c d e f多个目录。 rmdir：删除一个空文件夹 cp：复制文件或者文件夹 -a =-pdr -p 同时复制文件属性，比如修改日期 -d 复制时保留文件链接 -r: 复制文件夹时,递归复制子文件夹 -l 不复制，而是创建指向源文件的链接文件，链接文件名由目标文件给出。 note:可以在拷贝的同时重命名 mv：移动文件或者文件夹，可以在移动的时候重命名 rm ：删除文件或者文件夹 -r：递归删除 -f：强制删除 即没有提醒 ls :查看文件 -l 以列表形式查看 -h 以一种人性化的方式查看，也是文件的大小以合适的单位显示 -a 查看所有文件，包括隐藏文件 -i 显示出文件的i节点号 touch 文件名：创建文件 可以一次创建多个文件，以空格隔开 cat :查看文件内容 -n:带行号 tac:反向显示文件内容 more：分页查看文件内容 进入浏览模式后： f或者空格：下一页 enter：一行一行往下翻 q:退出 less:查看文件内容 空格翻页 回车换行 pageup：上一页 pagedown：下一页 上箭头：向上翻 下箭头：向下翻 /搜索词 n向下找 head -n 文件名 :查看文件前n行。缺省-n显示前10行 tail -n 文件名 ：查看文件的末尾几行 -f :动态显示文件末尾内容 ln:链接命令 -s创建软连接 硬链接和cp -p的区别是硬链接会同步更新 源文件如果丢失，硬链接依然存在。 硬链接和源文件的i节点相同。 硬链接不能夸分区，软连接可以跨分区。 硬链接不可以链接目录，链接可以 软连接文件具有的权限是ugo都是rwx 权限管理命令 chmod:修改文件或目录的权限，只有root和所有者可以更改 [{ugoa}{+-=}{rwx}] [文件或目录] [mode=421] [文件或目录] -R 递归修改 权限的数字表示： r-&gt;4 w-&gt;2 x-&gt;1 例：chmod u+x a.txt chmod g+w,o-r a.txt //同时做多个权限的修改 chmod g=rwx a.txt chmod 640 a.txt chmod -R 777 testdir //把目录和下面所有文件的权限 针对文件 针对目录 r 读权限 可以查看文件内容 可以列出目录中的内容 w 写权限 可以修改文件内容 可以在目录中创建、删除文件 x 执行权限 可以执行文件 可以进入目录 chown:更改文件所有者，只有root可以更改 chown root a.txt//把a.txt更改为root所有 chgrp:更改所属组 chgrp lambrother fengjie //把fengjie的所属组更改为lambrother umask -S:查看创建文件的缺省权限，即默认权限 umask 023:修改文件的缺省权限为777-023=754。即rwxr-xr-- 文件搜索命令 find:搜索制定范围内的文件 find [搜索范围] [匹配条件] -name 按文件名搜索 -iname 根据文件名查找，不区分大小写 -size +n大于 -n小于 n等于 这个n是数据块，在Linux中一个数据块是512字节大小 -user 根据所有者查找 -group 根据所属组查找 根据文件属性查找： -amin 访问时间 access -cmin 根据文件属性被修改的时间 change -mmin 根据文件内容被修改的时间 modify 例： find /etc -cmin -5 :查找/etc目录下五分钟内被修改过属性的文件和目录 -a 两个条件同时满足 find /etc -size +10 -a -size -50 -o 两个条件满足一个即可 -type f 文件 d 目录 l软连接文件 -inum 根据i节点查找 对找到的结果进行操作 -exec或者-ok 命令 {} ; 例如： find /etc -name init* -exec ls -l {} ; 对找到的文件名按列表查看 find /etc -name init :搜索目录/etc下面所有的init文件，精确匹配，包括子目录中的init文件 find / -size +204800 搜索大于100M的文件 locate:(查找速度非常快，因为它维护了一个文件库。缺点就是新建立的文件没有很快收录到文件库) locate 文件名 updatedb 更新locate的文件资料库 文件资料库不收录/tmp下的文件 -i 不区分大小写 which :查找命令的目录以及别名 which 命令 whereis :搜索命令所在目录及帮助文档路径。 grep:在文件中搜寻字符串匹配的行并输出，多个文件以空格隔开。 -i不区分大小写 -v排除指定字符串 -E 以正则表达式的方式搜索 -F 以普通文本的方式搜索 -n 显示搜索到的内容在文件中的行号。 帮助命令 man：查看命令或者配置文件的帮助信息 man 命令/配置文件 在手册里面，可以输入/要查找的str man ls man services man fstab //直接输入配置文件的名字，而不需要使用绝对路径 重点查看name选项和配置文件的格式。 如果一个命令即使命令又是配置文件，那么可以使用一个序号进行区分，比如： man 1 passwd 查看命令passwd的帮助 man 5 passwd 查看配置文件passwd的帮助 whatis ：得到命令的简要信息 apropos 配置文件名：查看配置文件的简短信息 命令 --help：查看命令的选项。 help ：查看shell内置命令的帮助信息。 shell内置命令是没有命令路径。不能使用man查看帮助。 用户管理命令 useradd: 添加用户 useradd 用户名 passwd: 修改用户密码 passwd 用户名 不加用户名直接更改自己的密码 who:查看当前的账户 显示的格式为： 登录用户名 登录终端（tty:本地登录 pts:远程终端） 登录时间 ip地址 w:查看更详细的用户登录信息。 压缩解压缩命令 gzip: 压缩：gzip 文件名 只能压缩文件不能压缩目录，压缩完源文件也不见了 解压缩：gunzip/gzip -d 压缩包名称 tar: -zcvf 压缩后文件名 打包的目录 :生成.tar.gz文件 注：这个命令先用tar归档，然后把归档的包压缩成.gz -zxvf 要解压的文件名 ：解压缩.tar.bz2的文件 -jcvf 压缩后的文件名 打包的目录：生成.tar.bz2 注：这个命令先用tar归档，然后把归档的包压缩成.bz2 -jxvf 要解压的文件名 :解压.tar.bz2的文件 zip: zip -r 压缩生成的文件名 要压缩的目录 zip 压缩生成的文件名 要压缩的文件。 unzip: unzip 要解压缩的文件 bzip2: bzip2 -k 要压缩的文件名 -k选项：保留源文件 bunzip2 -k 要解压的文件名 -k选项：保留压缩包 网络命令 write:给在线用户发送信息，用户不在线不行。以Ctrl+D保存 write 用户名 wall:给所有用户名发送信息 wall 要发送的信息 ping:测试网络连通性 ping ip地址 -c 要ping的次数 ifconfig: 直接回车查看当前网卡信息 ifconfig 网卡名 ip地址 临时修改网络ip ifconfig th0:0 192.168.1.100 netmask 255.255.255.0 给th0这个网卡新添加一个ip ifconfig eth0:0 down ifconfig eth0:0 up ifdown th0 禁用th0这块网卡 ifup th0 开启th0这块网卡 mail:邮件命令 mail 要发送的用户名 mail 直接回车：查看命令 help :查看支持的命令格式 输入序列号：查看邮件详细内容 h: 回到邮件列表 d 序列号：删除序列号对应的邮件 last:统计计算机所有用户登录的时间信息，以及重启信息 lastlog:所有用户最后一次登录的时间 -u 用户的uid 查看指定用户的登录信息。 traceroute:显示数据包到主机间的路径 traceroute 要探测的地址. -n 使用ip而不使用域名 nslookup :查看域名对应的ip地址 nsloppup www.baidu.com 查看百度的ip地址 netstat:显示网络相关信息 -t :tcp协议 -u :udp协议 -l:监听 -r:路由 -n:显示ip地址和端口号 netstat -tlun:查看本机监听的端口 netstat -an:查看所有的监听信息 netstat -rn ：查看路由表，即网管 wget 文件地址 下载文件 service network restart:重启网络服务。 telnet 域名或ip 远程管理与端口探测 如： telnet 192.168.2.3:80 探测192.168.2.3是否开启了80端口 mount:挂载命令 mount -t iso9660 /dev/sr0 /mnt/cdrom :把sr0挂在到cdrom 关机重启命令 shutdown:这个关机命令更安全一些，不推荐使用其他关机命令。 -h：关机 shutdown -h now shutdown -h 20:30 -r:重启 shutdown -r now -c:取消上次的关机命令 重启： init 6 reboot 关机： init 0 poweroff 系统运行级别： 0 关机 1 单用户 类似windows安全模式 2 不完全多用户，不含nfs服务 3 完全多用户 4 未分配 5 图形界面 6 重启 可以通过查看/etc/inittab来查看系统启动的运行级别 runlevel:查看当前的运行级别 init n:设置系统运行级别 logout:退出当前用户，返回到登录界面 其他命令 du -sh 文件名 ps: 静态查看系统进程，系统默认安装 ps -aux 使用BSD语法查看所有进程 ps -ef 标准语法查看所有进程 UID 程序被该 UID 所拥有 PID 就是这个程序的 ID PPID 则是其上级父程序的ID C CPU 使用的资源百分比 STIME 系统启动时间 TTY 登入者的终端机位置 TIME 使用掉的 CPU 时间。 CMD 所下达的指令为何 ps -aux --sort -pcpu,-pmem 根据CPU占用情况和内存占用情况来显示进程 watch -n 1 'ps -aux --sort -pcpu,-pmem' 每隔1秒监控一次进程情况 top: 动态查看系统的状态 lsof -Pti :8000 通过端口号获得进程pid kill -9 pid 杀死指定pid的进程，强行杀死。 history 查看历史命令 执行历史命令 !! 执行上一条命令 !n 执行历史命令的中第n条 !-n 执行导数第n条 !string 执行以string开头的历史命令行 !?string? 执行包含string的历史命令行 alias 给命令起别名 alias 命令='别名' alias -p 查看已存在的别名 unlias 取消别名 unlias name cal 查看某一年的日历，可以是1-9999中的任意一年 cal 88 zcat 查看压缩包中的内容 sed -i 's#old#new#g' 文件名 使用new替换文件中的old ssh root@192.168.8.15 &quot;ifconfig&quot; 远程执行命令 bash -x 脚本名 调试脚本 ","link":"https://gblw-blog.github.io/pVH7ViCHX/"},{"title":"Markdown语法","content":"Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。 相比WYSIWYG编辑器 优点： 1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点： 1、需要记一些语法（当然，是很简单。五分钟学会）。 2、有些平台不支持Markdown编辑模式。 一、标题 在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 示例： # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 三、引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; n个... 貌似可以一直加下去，但没神马卵用 示例： &gt;这是引用的内容 &gt;&gt;这是引用的内容 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 四、分割线 三个或者三个以上的 - 或者 * 都可以。 示例： --- ---- *** ***** 五、图片 语法： ![图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/ u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。可以选择自建图床，网上有相关教程 六、超链接 语法： [超链接名](超链接地址 &quot;超链接title&quot;) title可加可不加 注：Markdown本身语法不支持链接在新页面中打开 示例 &lt;a href=&quot;https://gblw-blog.github.io&quot; target=&quot;_blank&quot;&gt;HelloWorld&lt;/a&gt; 七、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 语法： 数字加点 列表内容 列表内容 列表内容 注意：序号跟内容之间要有空格 上一级和下一级之间敲三个空格即可 八、表格 语法： 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 九、代码 语法： 单行代码：代码之间分别用一个反引号包起来 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 () 代码... 代码... 代码... () 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 `create database hero;` 代码块 (```) function fun(){ echo &quot;这是一句非常牛逼的代码&quot;; } fun(); (```) 十、流程图 ```flow st=&gt;start: 开始 op=&gt;operation: My Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op &amp;``` ","link":"https://gblw-blog.github.io/markdown-ji-ben-yu-fa/"},{"title":"H5相关整理","content":"&lt;!--...--&gt; 定义注释。 &lt;!DOCTYPE&gt; 定义文档类型。 &lt;a&gt; 定义超链接。 &lt;abbr&gt; 定义缩写。 &lt;acronym&gt; HTML 5 中不支持。定义首字母缩写。 &lt;address&gt; 定义地址元素。 &lt;applet&gt; HTML 5 中不支持。定义 applet。 &lt;area&gt; 定义图像映射中的区域。 &lt;article&gt; 定义 article。 &lt;aside&gt; 定义页面内容之外的内容。 &lt;audio&gt; 定义声音内容。 &lt;b&gt; 定义粗体文本。 &lt;base&gt; 定义页面中所有链接的基准 URL。 &lt;basefont&gt; HTML 5 中不支持。请使用 CSS 代替。 &lt;bdi&gt; 定义文本的文本方向，使其脱离其周围文本的方向设置。 &lt;bdo&gt; 定义文本显示的方向。 &lt;big&gt; HTML 5 中不支持。定义大号文本。 &lt;blockquote&gt; 定义长的引用。 &lt;body&gt; 定义 body 元素。 &lt;br&gt; 插入换行符。 &lt;button&gt; 定义按钮。 &lt;canvas&gt; 定义图形。 &lt;caption&gt; 定义表格标题。 &lt;center&gt; HTML 5 中不支持。定义居中的文本。 &lt;cite&gt; 定义引用。 &lt;code&gt; 定义计算机代码文本。 &lt;col&gt; 定义表格列的属性。 &lt;colgroup&gt; 定义表格列的分组。 &lt;command&gt; 定义命令按钮。 &lt;datalist&gt; 定义下拉列表。 &lt;dd&gt; 定义定义的描述。 &lt;del&gt; 定义删除文本。 &lt;details&gt; 定义元素的细节。 &lt;dfn&gt; 定义定义项目。 &lt;dir&gt; HTML 5 中不支持。定义目录列表。 &lt;div&gt; 定义文档中的一个部分。 &lt;dl&gt; 定义定义列表。 &lt;dt&gt; 定义定义的项目。 &lt;em&gt; 定义强调文本。 &lt;embed&gt; 定义外部交互内容或插件。 &lt;fieldset&gt; 定义 fieldset。 &lt;figcaption&gt; 定义 figure 元素的标题。 &lt;figure&gt; 定义媒介内容的分组，以及它们的标题。 &lt;font&gt; HTML 5 中不支持。 &lt;footer&gt; 定义 section 或 page 的页脚。 &lt;form&gt; 定义表单。 &lt;frame&gt; HTML 5 中不支持。定义子窗口（框架）。 &lt;frameset&gt; HTML 5 中不支持。定义框架的集。 &lt;h1&gt; to &lt;h6&gt; 定义标题 1 到标题 6。 &lt;head&gt; 定义关于文档的信息。 &lt;header&gt; 定义 section 或 page 的页眉。 &lt;hgroup&gt; 定义有关文档中的 section 的信息。 &lt;hr&gt; 定义水平线。 &lt;html&gt; 定义 html 文档。 &lt;i&gt; 定义斜体文本。 &lt;iframe&gt; 定义行内的子窗口（框架）。 &lt;img&gt; 定义图像。 &lt;input&gt; 定义输入域。 &lt;ins&gt; 定义插入文本。 &lt;keygen&gt; 定义生成密钥。 &lt;isindex&gt; HTML 5 中不支持。定义单行的输入域。 &lt;kbd&gt; 定义键盘文本。 &lt;label&gt; 定义表单控件的标注。 &lt;legend&gt; 定义 fieldset 中的标题。 &lt;li&gt; 定义列表的项目。 &lt;link&gt; 定义资源引用。 &lt;map&gt; 定义图像映射。 &lt;mark&gt; 定义有记号的文本。 &lt;menu&gt; 定义菜单列表。 &lt;meta&gt; 定义元信息。 &lt;meter&gt; 定义预定义范围内的度量。 &lt;nav&gt; 定义导航链接。 &lt;noframes&gt; HTML 5 中不支持。定义 noframe 部分。 &lt;noscript&gt; 定义 noscript 部分。 &lt;object&gt; 定义嵌入对象。 &lt;ol&gt; 定义有序列表。 &lt;optgroup&gt; 定义选项组。 &lt;option&gt; 定义下拉列表中的选项。 &lt;output&gt; 定义输出的一些类型。 &lt;p&gt; 定义段落。 &lt;param&gt; 为对象定义参数。 &lt;pre&gt; 定义预格式化文本。 &lt;progress&gt; 定义任何类型的任务的进度。 &lt;q&gt; 定义短的引用。 &lt;rp&gt; 定义若浏览器不支持 ruby 元素显示的内容。 &lt;rt&gt; 定义 ruby 注释的解释。 &lt;ruby&gt; 定义 ruby 注释。 &lt;s&gt; HTML 5 中不支持。定义加删除线的文本。 &lt;samp&gt; 定义样本计算机代码。 &lt;script&gt; 定义脚本。 &lt;section&gt; 定义 section。 &lt;select&gt; 定义可选列表。 &lt;small&gt; 将旁注 (side comments) 呈现为小型文本。 &lt;source&gt; 定义媒介源。 &lt;span&gt; 定义文档中的 section。 &lt;strike&gt; HTML 5 中不支持。定义加删除线的文本。 &lt;strong&gt; 定义强调文本。 &lt;style&gt; 定义样式定义。 &lt;sub&gt; 定义下标文本。 &lt;summary&gt; 定义 details 元素的标题。 &lt;sup&gt; 定义上标文本。 &lt;table&gt; 定义表格。 &lt;tbody&gt; 定义表格的主体。 &lt;td&gt; 定义表格单元。 &lt;textarea&gt; 定义 textarea。 &lt;tfoot&gt; 定义表格的脚注。 &lt;th&gt; 定义表头。 &lt;thead&gt; 定义表头。 &lt;time&gt; 定义日期/时间。 &lt;title&gt; 定义文档的标题。 &lt;tr&gt; 定义表格行。 &lt;track&gt; 定义用在媒体播放器中的文本轨道。 &lt;tt&gt; HTML 5 中不支持。定义打字机文本。 &lt;u&gt; HTML 5 中不支持。定义下划线文本。 &lt;ul&gt; 定义无序列表。 &lt;var&gt; 定义变量。 &lt;video&gt; 定义视频。 &lt;xmp&gt; HTML 5 中不支持。定义预格式文本。 ","link":"https://gblw-blog.github.io/h5-xiang-guan-zheng-li/"},{"title":"RedHat常用命令","content":" 查询注册模块软件 yum list all | grep subscription 卸载注册模块 yum remove subscription-manager 立即重启 shutdown -r now 解压到指定路径 tar zxvf /source/kernel.tgz -C /Document 打包压缩文件 tar -cvf /home/www/images.tar /home/www/images ← 仅打包，不压缩 tar -zcvf /home/www/images.tar.gz /home/www/images ← 打包后，以gzip压缩 创建目录 mkdir -p[递归创建] 删除非空目录 rmdir（只能删除空目录） // rmdir 目标目录 rm (默认删除文件) -r[删除目录] -f[不希望询问确认] // rm -rf 目标文件 复制文件 cp( -r[复制目录] -p[复制时保持文件属性] // cp -rp 目标文件 目标目录 移动文件 mv（剪切文件） // mv 目标文件 目标目录 （将目标目录属性改为文件名时，可对文件进行改名） 创建文件 touch //touch 文件名 查看文件内容 cat -n[显示行号] // cat -n 目标文件 反向显示文件内容 tac(适用于短文件) 分页浏览文件 mroe(可用 空格 或 F 翻页，回车 换行， q 退出) // more 目标文件 less（在 more 命令的基础上还可用 上下箭头 换行， pgup、pgdown 翻页， / 加搜索内容查找， n 跳转下一个匹配项， N 跳转至上一个匹配项） // less 目标文件 查看文件头 head(默认前10行) -n[指定行数] // head -n 5 目标文件 查看文件尾 tail（默认10行） -n[显示指定行数] // tail -n 5 目标文件 创建连接文件 ln(默认创建硬链接，实时更新) -s[创建软连接] // ln -s 目标目录/[文件名] 更改文件权限 chmod -R[递归更改] // chmod -R 777 目标文件 更改文件所有者 chown // chown 目标用户 目标文件 文件搜索 find -name[按文件名搜索，通配符 * ？] -iname[按文件名搜索忽略大小写] -size[按文件大小搜索， + 大于， - 小于，缺省表示等于] -type[根据类型查找， d 为目录， f 为文件] -user[根据所属用户查找] -group[根据所属组查找] -cmin[根据更改时间查找，+2两分钟前，-2两分钟内] -mtime[根据修改时间，+2两天前，-2两天内] -a[查询条件 and 连接符] -r[查询条件 or 连接符] // find -name *关键字* // find -size +1M (大于1M的文件) // find -iname *关键字* 快速文件查找 locate（从Linux文件资料库查找，系统定期自动更新） -i[忽略大小写] 搜索命令所在路径及别名 which // which 命令名 搜索文件中指定内容 grep(^a 以a开头) -i[忽略大小写] -v[排除指定字符] // grep ^aa a.txt &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ls |grep -v ^G 查看命令帮助 man // man ls info // info ls 查看用户登录信息 who 压缩文件 gzip -d[解压文件] // gzip -d 目标.gz文件 目录打包压缩 tar -c[打包] -v[显示详细信息] -f[指定文件名] -z[打包同时压缩] -x[解包] // tar -zcvf 打包压缩后文件名 目标文件名 // tar -zxvf 目标文件名 压缩 zip 文件 zip -r[压缩目录] // zip 压缩后文件名 目标文件名 解压 zip 文件 unzip 目标文件名 压缩 bz2 文件 biz（默认只能压缩文件） -k[压缩后保留文件] // biz 目标文件 // 打包目录并压缩 tar -cjf 打包压缩后文件名 目标文件名 解压 bz2 文件 bunzip2 -k[解压后保留原文件] // bunzip2 -k 目标文件名 // 解压 tar.bz2 文件 tar -xjf 目标文件名 查看所有已安装软件 rpm -qa 卸载已安装软件 rpm -e --nodeps 软件包名 rpm 软件包安装 rpm -ivh 软件包名 配置全局环境变量（ Java 为例） export JAVA_HOME=/usr/java/jdk1.7.0_04 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin 更新环境变量配置信息 source /etc/profile 跳转上次所在目录 cd - ","link":"https://gblw-blog.github.io/redhat-chang-yong-ming-ling/"},{"title":"Oracle常用命令","content":"查询所有表空间 select tablespace_name from dba_tablespaces; 创建表空间 create tablespace EVTJDLPROJECT datafile 'D:\\OracleDataSpace\\EVTJDLPROJECT.dbf' size 10m autoextend on next 20m maxsize 20480m extent management local; 删除表空间 drop tablespace EVTJDLPROJECT including contents and datafiles cascade constraints; 新建用户 create user tianjin identified by tianjin; 新建用户并指定默认表空间 create user tianjin identified by tianjin default tablespace EVTJDLPROJECT; 删除用户 drop user tianjin; 修改已存在用户默认表空间 alter user tianjin default tablespace EVTJDLPROJECT; 角色授权 oracle为兼容以前版本，提供三种标准角色（role）:connect/resource和dba connect role(连接角色) –临时用户，特指不需要建表的用户，通常只赋予他们connect role. –connect是使用oracle简单权限，这种权限只对其他用户的表有访问权限，包括select/insert/update和delete等。 –拥有connect role 的用户还能够创建表、视图、序列（sequence）、簇（cluster）、同义词(synonym)、回话（session）和其他 数据的链（link） resource role(资源角色) –更可靠和正式的数据库用户可以授予resource role。 –resource提供给用户另外的权限以创建他们自己的表、序列、过程(procedure)、触发器(trigger)、索引(index)和簇(cluster)。 dba role(数据库管理员角色) –dba role拥有所有的系统权限 –包括无限制的空间限额和给其他用户授予各种权限的能力。system由dba用户拥有 eg: grant connect, resource to tianjin; 撤销授权 revoke connect, resource from tianjin; 导出数据 exp test/test@orcl file=F:\\TEST.dmp 导入数据 imp scott/tiger@orcl full=y file=D:\\OracleDataSpace\\TEST.dmp 导入dmp到指定表空间 IMP tianjin/tianjin file=D:\\OracleDataSpace\\TEST.dmp fromuser=test touser=tianjin ignore=yes tablespaces=EVTJDLPROJECT 导出单张表 exp tianjin/tianjin@orcl file=D:\\OracleDataSpace\\EVTJDLPROJECT.dmp tables=USER,ROLES ","link":"https://gblw-blog.github.io/oracle-chang-yong-ming-ling/"},{"title":"Docker常用操作整理","content":" 一、Docker 命令分类 Docker 环境信息 docker [version | info] 容器生命周期管理 docker [create | exec | run | start | stop | restart | kill | rm | pause | unpause] 容器操作管理 docker [ps | inspect | top | attach | wait | export | prot | rename | stat] 容器 rootfs 命令 docker [commit | cp | diff] 镜像仓库 docker [login | pull | push | search] 本地镜像管理 docker [build | images | rmi | tag | save | load | import] 容器资源管理 docker [volume | network] 系统日志信息 docker [event | history | logs] 二、Docker 镜像相关命令 镜像拉取 # 拉取最新镜像 docker pull 镜像名 # 拉取指定版本镜像 docker pull 镜像名:版本 Tips： 有些镜像后缀除了包含版本号外还会有其他信息常见的包括： slim：该标识意味着使用了更好的压缩技术（镜像瘦身），使得镜像包体积更小 alpine：该标识意味着使用了 alpine 的 Linux内核，这个内核的特点就是非常小 查看本地已有镜像 # 方式一(推荐) docker images # 方式二 docker image ls 列名含义： REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：创建时间 SIZE：镜像大小 3. 镜像备份（镜像导出） docker save 镜像名:版本号 -o 导出后的文件名.tar Tips： 如果要导出多个镜像用空格隔开即可 -o 参数表示导出，可用 &gt; 代替 4. 导入本地镜像 docker load -i 导入的文件名 Tips： -i 参数表示导入，可用 &lt; 代替 镜像查询（从镜像源） docker search 镜像名 查看镜像详细信息 # 查看所有信息 docker inspect 镜像名称:版本 # 查看指定信息 docker inspect -f {{&quot;.属性名称&quot;}} 镜像名:版本号 Tips： 查看指定信息时 属性名称 必须与与镜像的属性信息名称大小写相同 属性名称 可通过 查看所有信息 命令的返回结果中看到 7. 查看镜像层信息 docker history 镜像名:版本号 Tips： 该命令结果信息显示不好，了解即可 镜像改名 docker tag 原镜像名:版本号 新镜像名:版本号 删除镜像 # 普通删除 docker rmi 镜像名:版本号 # 强制删除 docker rmi -f 镜像名:版本号 # 不删除未带 tag 的父镜像 docker rmi -no-prune 镜像名:版本号 # 删除所有镜像 docker rmi $(docker images -q) Tips： 删除镜像时也可通过 IMAGE ID 的值删除，而不使用 镜像名:版本号 的方式。但由于 docker 客户端显示的是短 ID 所以 IMAGE ID 有时会重复，进而导致删除失败。所以不建议使用这种方式。 10. 清理临时文件和未被引用的镜像 docker image prune 常用参数： -a：删除所有没用的镜像，而不仅是临时文件 -f：无需确认，强制删除镜像 三、Docker 容器相关命令 启动容器 # 以终端交互方式启动容器并在停止后自动删除 docker run -it --rm 镜像名:版本号 常用参数： -d：后台启动容器，并返回容器 ID -e：设置环境变量，格式为：-e 变量名=变量值 -h：为容器指定 hostname，格式为：-h 自定义hostname （这里的 hostname 可以近似理解为 Windows 中的用户名） -i：以交互模式启动容器，通常与 -t连用 -P：经容器内部端口随机映射至宿主机端口*（不推荐）* -p：绑定容器内部指定端至宿主机指定端口，格式为：宿主机端口:容器内端口 -t：为容器分配一个伪终端，通常与 -i 连用 -v：绑定数据卷，格式为：-v 宿主机绝对路径目录:容器内目录的绝对路径 详见：五-2 --name：为容器指定名称，格式为：--name 自定义容器名 --rm：容器停止后自动删除容器。（与 -d 参数互斥） 2. 查看容器日志 docker logs 容器名称 **Tips：**这里可将容器名称替换为容器 ID，不推荐 常用参数： -f：动态显示 -tail：列出最后N条日志信息，格式为：-tail 条数 3. 查看已有容器 docker ps 容器名称 列名含义： CONTAINER ID：容器 ID IMAGE：使用的镜像 COMMAND：启动容器时使用的命令（容器内部） CREATED：创建时间 STATUS：容器状态，类型：created：已创建、restarting：重启中、running：运行中、removing:迁移中、paused：暂停、exited、停止、dead：死亡 PORTS：容器端口信息和连接类型（tcp/udp） NAMES：容器名称 常用参数： -a：显示所有容器，包括未运行的 -q：只显示容器 ID 4. 删除容器 # 删除指定容器 docker rm 容器名 # 删除所有已停止运行的容器 docker rm $(docker ps -aq) # 删除所有容器，包括正在运行的（有点骚，不推荐） docker rm -f $(docker ps -aq) 创建容器 # 创建一个以终端交互方式启动容器并在停止后自动删除 docker create -it --rm 镜像名:版本号 Tips： create 命令与 run 命令相似，不同之处在于 create 命令只创建，不运行 create 命令不能使用 -d 参数 不推荐，直接用 run 命令就好了，何必脱了裤子放屁 6. 启动容器 # 启动指定容器 docker start 容器名 # 启动所有容器 docker start $(docker ps -aq) 停止容器 # 停止指定容器 docker stop 容器名 # 停止所有容器 docker stop $(docker ps -aq) # 强制停止容器 docker kill 容器名 重启容器 # 重启指定容器 docker restart 容器名 # 重启所有容器 docker restart $(docker ps -aq) 进入容器 # 有 bash 命令的 Linux 如：CentOS docker exec -it 容器名 /bin/bash # 没有 bash 命令的 Linux 如：alpine docker exec -it 容器名 sh Tips： 对于有没有 bash 命令，这点需要进行尝试，如果进入报错或以 bash 进入后按 Tab 无法补全命令，则有可能才容器的系统中没有 bash 命令 常用参数： -i：以交互方式进入 -t：分配一个伪终端 退出容器：进入容器后想退出直接在命令行敲 exit 命令即可 10. 查看容器信息 docker inspect 容器名称 四、Docker 网络相关命令 自定义网关 # 查看当前已有网络模式（docker 安装完成后，会自动创建 bridge、host、none 三种网络驱动） docker network ls # 创建自定义桥接网关 docker network create 自定义网关名 # 启动容器并指定网关 docker run -itd --name 容器名 --network 网关名 镜像名 # 将运行中的容器绑定至自定义网关 docker network connect 网关名 容器名 # 删除自定义网关 docker network rm 网关名 # 将容器与指定网关断开 docker network disconnect 网关名 容器名 # 查看网络详情 docker network inspect 网关名 说明：这种自定义网关的网络连接方式，可以让多个连接在同一个自定义网关上的容器之间，能够通过容器名进互相访问，而不使用易变的容器内部 IP 地址 # 进入某容器 docker exec -it 容器名 /bin/bash # 通过容器名连接其他容器 ping 容器名 设置固定IP # 1) 创建自定义网关 docker network create --subnet 子网地址/24 --gateway 网关地址 自定义网关名 # 2) 启动容器时设置静态IP docker run -itd --network 网关名 --ip 静态地址 容器名:版本号 示例： docker network create --subnet 155.155.0.0/24 --gateway 155.155.0.1 my_bridge docker run -itd --name nginx -p 80:80 --network my_bridge --ip 155.155.0.99 nginx:1.19.3 五、Docker数据卷 容器内外文件复制 # 复制容器内的文件至宿主机 docker cp 容器名:容器内文件路径 宿主机目标路径 # 复制宿主机文件至容器内 docker cp 宿主机文件路径 容器名:容器内目标路径 说明：cp 命令既可以复制文件也可以复制目录 数据卷挂载 # 宿主机数据卷挂载（推荐） docker run -v 宿主机绝对路径目录:容器内目录的绝对路径 镜像名 # 命名数据卷挂载 docker run -v 数据卷名称:容器内目录的绝对路径 镜像名 # 匿名数据卷挂载 docker run -v 容器内目录的绝对路径 镜像名 # 查看数据卷 docker volume ls # 查看数据卷信息 docker volume inspect 数据卷名称 # 清理无用数据卷 docker volume prune Tips： 挂载数据卷时推荐使用 docker run 命令去挂载，这种方式最简单 docker 官网推荐尽量对目录进行挂载而不是文件 宿主机中的目录或文件不需要预先存在，在需要时 docker 会自动创建 如果将宿主机的空目录挂载至容器的非空目录时，docker 会将容器内目录下的文件拷贝至宿主机挂载目录 如果将宿主机的非空目录挂载至容器的目录上时，docker 会将容器内资源隐藏，保留宿主机目录中的资源 3. 数据卷容器 # 创建数据卷容器 docker run -d --name 容器名称 -v 宿主机绝对路径目录:容器内目录的绝对路径 镜像名 # 启动容器 docker run --volumes-frome 数据卷容器名 镜像名 Tips： 数据卷容器没有限制，可以是 CentOS 的容器也可以是 hello-world 的容器 创建后的数据卷容器可以停止状态也可以是运行状态，该容器的运行状态对数据卷容器的功能使用没有影响 创建数据卷容器时容器内目录的绝对路径必须与要使用该数据卷容器的容器内目录的绝对路径相同 有些镜像的容器是不支持数据卷容器功能的，换句话说就是：映射在宿主机上的容器内目录中的资源文件带锁，只允许一个应用读写。例如：MySQL 六、Docker-compose 官网 https://github.com/docker/compose 下载地址 https://github.com/docker/compose/releases/tag/1.29.2 安装 docker-compose # 移动文件 mv /home/sir/docker-compose-Linux-x86_64 /usr/local/bin/docker-compose # 修改权限 开发环境可以授予 777 chmod +x /usr/local/bin/docker-compose # 检查安装情况 docker-compose -v # 卸载 rm -rf /usr/local/bin/docker-compose # 重启 reboot docker-compose 常用命令 # 前台启动服务 docker-compose up # 后台启动服务 docker-compose up -d # 停止服务并删除容器 docker-compose down # 列出所有运行容器 docker-compose ps # 查看服务日志 docker-compo logs # 构建或重新构建服务 docker-compose build # 运行服务 docker-compose start # 停止服务 docker-compose stop # 重启服务 docker-compose restart Tips： 运行 docker-compose 命令时，必须在 docker-compose.yaml 文件夹内 如果 docker-compose 配置文件名不是 docker-compose.yaml 则需要通过 -f 参数来指定配置文件 ","link":"https://gblw-blog.github.io/docker-chang-yong-cao-zuo-zheng-li/"},{"title":"国内docker镜像拉取加速","content":"mkdir -p /etc/docker tee /etc/docker/daemon.json &lt;&lt;-'EOF' { &quot;registry-mirrors&quot;: [ &quot;https://docker.mirrors.ustc.edu.cn&quot; &quot;https://dockerhub.azk8s.cn&quot;, &quot;http://f1361db2.m.daocloud.io&quot;, &quot;https://reg-mirror.qiniu.com&quot;, &quot;https://hub-mirror.c.163.com&quot;, &quot;https://mirror.ccs.tencentyun.com&quot; ] } EOF systemctl daemon-reload systemctl restart docker docker info ","link":"https://gblw-blog.github.io/guo-nei-docker-jing-xiang-la-qu-jia-su/"},{"title":"常用GIT操作命令","content":"git add --&gt;添加进暂存区 git commit --&gt;提交到本地历史仓库 git log --&gt;查看日志 git reflog --&gt; 查看日志 git reset --hard --&gt;git历史版本切换 git branch --&gt;查看分支列表 git branch xxx --&gt;创建新分支 git checkout --&gt;切换分支 git merge 分支名 --&gt;合并分支 git branch -d 分支名 --&gt;删除分支 git config user.name --&gt;查看git账户 git config user.email --&gt;查看git邮箱 git config --global user.name &quot;账户名&quot; git config --global user.email &quot;邮箱&quot; cd ~/.ssh --&gt;查看是否生成过ssh公钥 ssh-keygen -t rsa -C &quot;邮箱&quot; --&gt;生成ssh公钥 cat ~/.ssh/id_rsa.pub --&gt;查看生成公钥 ssh -T git@github.com --&gt;测试公钥连通性 git remote add 自定义远程仓库名称 远程仓库URL --&gt; 重命名远程仓库名称 git push -u 自定义远程仓库名称 分支名 --&gt;推送到远程仓库 git clone 远程仓库地址 --&gt;克隆远程仓库 git pull 远程仓库名 分支名 --&gt; 拉取远程仓库 ","link":"https://gblw-blog.github.io/chang-yong-git-cao-zuo-ming-ling/"},{"title":"审计规则整理","content":"禁止外发邮件 (Subject|HELO|SMTP) 屏蔽邮箱 /^.*@(guerrillamail.(info|biz|com|de|net|org)|guerrillamailblock.com|sharklasers.com|grr.la|pokemail.net|spam4.me|(mail.)?bccto.me|chacuo.net|027168.com)$/i 屏蔽百度 (api|ps|sv|offnavi|newvector|ulog.imap|newloc)(.map|).(baidu|n.shifen).com 屏蔽BT (torrent|.torrent|peer_id=|announce|info_hash|get_peers|find_node|BitTorrent|announce_peer|protocol|announce.php?passkey=) 屏蔽360全家桶 (.+.|^)(360|so|qihoo|360safe|qhimg|360totalsecurity|yunpan).(cn|com) 具体规则 禁用 BT 防止版权争议 BitTorrent protocol 数据包明文匹配 禁止 百度高精度定位 防止IP与客户端地理位置被记录 (api|ps|sv|offnavi|newvector|ulog.imap|newloc)(.map|).(baidu|n.shifen).com 数据包明文匹配 禁止360有毒服务 屏蔽360 (.+.|^)(360|so).(cn|com) 数据包明文匹配 禁止 邮件滥发 防止垃圾邮件滥用 (Subject|HELO|SMTP) 数据包明文匹配 屏蔽轮子网站 (.*.||)(dafahao|minghui|dongtaiwang|epochtimes|ntdtv|falundafa|wujieliulan).(org|com|net) 数据包明文匹配 屏蔽 BT（2） (torrent|.torrent|peer_id=|info_hash|get_peers|find_node|BitTorrent|announce_peer|announce.php?passkey=) 数据包明文匹配 屏蔽Spam邮箱 (JasonLee修改完善) (^.*@)(guerrillamail|guerrillamailblock|sharklasers|grr|pokemail|spam4|bccto|chacuo|027168).(info|biz|com|de|net|org|me|la) 数据包明文匹配 屏蔽迅雷 (.?)(xunlei|sandai|Thunder|XLLiveUD)(.) 数据包明文匹配 可基本屏蔽掉迅雷的网站，并且在全局模式下会影响迅雷的下载能力 ","link":"https://gblw-blog.github.io/shen-ji-gui-ze-zheng-li/"},{"title":"面向对象基础","content":"1. 类和对象 **面向对象和面向过程的思想对比 : ** ​ **面向过程 ：**是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的 ​ **面向对象 ：**是一种以对象为中心的编程思想，通过指挥对象实现具体的功能 1.1 类和对象的关系 客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。 类 类的理解 类是对现实生活中一类具有共同属性和行为的事物的抽象 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合 简单理解：类就是对现实事物的一种描述 类的组成 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸） 行为：指事物能执行的操作，例如：手机事物（打电话，发短信） 类和对象的关系 类：类是对现实生活中一类具有共同属性和行为的事物的抽象 对象：是能够看得到摸的着的真实存在的实体 简单理解：类是对事物的一种描述，对象则为具体存在的事物 1.2 类的定义【应用】 类的组成是由属性和行为两部分组成 **属性：**在类中通过成员变量来体现（类中方法外的变量） **行为：**在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可） 类的定义步骤： ​ ① 定义类 ​ ② 编写类的成员变量 ​ ③ 编写类的成员方法 public class Student { // 属性 : 姓名, 年龄 // 成员变量: 跟之前定义变量的格式一样, 只不过位置发生了改变, 类中方法外 String name; int age; // 行为 : 学习 // 成员方法: 跟之前定义方法的格式一样, 只不过去掉了static关键字. public void study(){ System.out.println(&quot;学习&quot;); } } 1.3 对象的创建和使用 创建对象的格式： 类名 对象名 = new 类名(); 调用成员的格式： 对象名.成员变量 对象名.成员方法(); **示例代码 : ** package com.itheima.object1; public class TestStudent { /* 创建对象的格式: 类名 对象名 = new 类名(); 调用成员变量的格式: 对象名.变量名 调用成员方法的格式: 对象名.方法名(); */ public static void main(String[] args) { // 类名 对象名 = new 类名(); Student stu = new Student(); // 对象名.变量名 // 默认初始化值 System.out.println(stu.name); // null System.out.println(stu.age); // 0 stu.name = &quot;张三&quot;; stu.age = 23; System.out.println(stu.name); // 张三 System.out.println(stu.age); // 23 // 对象名.方法名(); stu.study(); // com.itheima.object1.Student@b4c966a // 全类名(包名 + 类名) System.out.println(stu); } } 1.4 案例-手机类的创建和使用 **需求 ：**首先定义一个手机类，然后定义一个手机测试类，在手机测试类中通过对象完成成员变量和成员方法的使用 分析 ： 成员变量：品牌, 价格 成员方法：打电话, 发短信 示例代码： package com.itheima.test1; public class Phone { // 品牌, 价格 String brand; int price; // 打电话, 发短信 public void call(String name){ System.out.println(&quot;给&quot;+name+&quot;打电话&quot;); } public void sendMessage(){ System.out.println(&quot;群发短信&quot;); } } package com.itheima.test1; public class TestPhone { public static void main(String[] args) { // 1. 创建对象 Phone p = new Phone(); // 2. 给成员变量进行赋值 p.brand = &quot;大米&quot;; p.price = 2999; // 3. 打印赋值后的成员变量 System.out.println(p.brand + &quot;...&quot; + p.price); // 4. 调用成员方法 p.call(&quot;阿强&quot;); p.sendMessage(); } } 总结： 多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份 当多个对象的引用指向同一个内存空间（变量所记录的地址值是一样的） 只要有任何一个对象修改了内存中的数据，随后，无论使用哪一个对象进行数据获取，都是修改后的数据。 2. 成员变量和局部变量 2.1 成员变量和局部变量的区别 **类中位置不同：**成员变量（类中方法外）局部变量（方法内部或方法声明上） **内存中位置不同：**成员变量（堆内存）局部变量（栈内存） **生命周期不同：**成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失） **初始化值不同：**成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用） 3. 封装 3.1 private关键字 ​ 概述 : private是一个修饰符，可以用来修饰成员（成员变量，成员方法） ​ 特点 : 被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用， 提供相应的操作 ​ 提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰 ​ 提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰 ​ 示例代码： /* 学生类 */ class Student { //成员变量 String name; private int age; //提供get/set方法 public void setAge(int a) { if(a&lt;0 || a&gt;120) { System.out.println(&quot;你给的年龄有误&quot;); } else { age = a; } } public int getAge() { return age; } //成员方法 public void show() { System.out.println(name + &quot;,&quot; + age); } } /* 学生测试类 */ public class StudentDemo { public static void main(String[] args) { //创建对象 Student s = new Student(); //给成员变量赋值 s.name = &quot;林青霞&quot;; s.setAge(30); //调用show方法 s.show(); } } 3.2 private关键字的使用 需求： 定义标准的学生类，要求name和age使用private修饰 并提供set和get方法以及便于显示数据的show方法 测试类中创建对象并使用，最终控制台输出 林青霞，30 示例代码： /* 学生类 */ class Student { //成员变量 private String name; private int age; //get/set方法 public void setName(String n) { name = n; } public String getName() { return name; } public void setAge(int a) { age = a; } public int getAge() { return age; } public void show() { System.out.println(name + &quot;,&quot; + age); } } /* 学生测试类 */ public class StudentDemo { public static void main(String[] args) { //创建对象 Student s = new Student(); //使用set方法给成员变量赋值 s.setName(&quot;林青霞&quot;); s.setAge(30); s.show(); //使用get方法获取成员变量的值 System.out.println(s.getName() + &quot;---&quot; + s.getAge()); System.out.println(s.getName() + &quot;,&quot; + s.getAge()); } } 3.3 this关键字【应用】 概述 : this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题） 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量 代码实现 : public class Student { private String name; private int age; public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void show() { System.out.println(name + &quot;,&quot; + age); } } 3.4 this内存原理【理解】 注意 : this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象 3.5 封装思想 封装概述 是面向对象三大特征之一（封装，继承，多态） 是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的 封装原则 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法 封装好处 通过方法来控制成员变量的操作，提高了代码的安全性 把代码用方法进行封装，提高了代码的复用性 4. 构造方法 4.1 构造方法的格式和执行时机 格式注意 : 方法名与类名相同，大小写也要一致 没有返回值类型，连void都没有 没有具体的返回值（不能由retrun带回结果数据） 执行时机 ： 创建对象的时候调用，每创建一次对象，就会执行一次构造方法 不能手动调用构造方法 示例代码： class Student { private String name; private int age; //构造方法 public Student() { System.out.println(&quot;无参构造方法&quot;); } public void show() { System.out.println(name + &quot;,&quot; + age); } } /* 测试类 */ public class StudentDemo { public static void main(String[] args) { //创建对象 Student s = new Student(); s.show(); } } 4.2 构造方法的作用 用于给对象的数据（属性）进行初始化 package com.itheima.constructor; public class Student { /* 格式: 1. 方法名需要跟类名相同, 大小写也要一致 2. 没有返回值类型, 连void都没有 3. 没有具体的返回值(不能由return带回具体的结果) */ private String name; private int age; // 1. 如果一个类中没有编写任何构造方法, 系统将会提供一个默认的无参数构造方法 public Student(){} // 2. 如果手动编写了构造方法, 系统就不会再提供默认的无参数构造方法了 public Student(String name, int age){ this.name = name; this.age = age; System.out.println(&quot;我是Student类的构造方法&quot;); } public void show(){ System.out.println(name + &quot;...&quot; + age); } } package com.itheima.constructor; public class TestStudent { public static void main(String[] args) { Student stu1 = new Student(&quot;张三&quot;,23); stu1.show(); Student stu2 = new Student(); } } 4.3 构造方法的注意事项 构造方法的创建 : ​ 如果没有定义构造方法，系统将给出一个默认的无参数构造方法 ​ 如果定义了构造方法，系统将不再提供默认的构造方法 构造方法的创建 : ​ 如果没有定义构造方法，系统将给出一个默认的无参数构造方法如果定义了构造方法，系统将不再提供默认的构造方法 推荐的使用方式 : ​ 无论是否使用，都手动书写无参数构造方法，和带参数构造方法 4.4 标准类的代码编写和使用 代码 : package com.itheima.test3; /* JavaBean类: 封装数据 */ public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void show(){ System.out.println(name + &quot;...&quot; + age); } } package com.itheima.test3; public class TestStudent { public static void main(String[] args) { // 1. 无参数构造方法创建对象, 通过setXxx方法给成员变量进行赋值 Student stu1 = new Student(); stu1.setName(&quot;张三&quot;); stu1.setAge(23); stu1.show(); // 2. 通过带参数构造方法, 直接给属性进行赋值 Student stu2 = new Student(&quot;李四&quot;,24); stu2.show(); } } ","link":"https://gblw-blog.github.io/mian-xiang-dui-xiang-ji-chu/"},{"title":"Alist常用样式","content":"黑猫： &lt;!--看板娘 - 黑猫--&gt; &lt;script src=&quot;https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; L2Dwidget.init({ &quot;model&quot;: { jsonPath: &quot;https://unpkg.com/live2d-widget-model-hijiki/assets/hijiki.model.json&quot;, &lt;!--这里改模型，前面后面都要改--&gt; &quot;scale&quot;: 1 }, &quot;display&quot;: { &quot;position&quot;: &quot;left&quot;, &lt;!--设置看板娘的上下左右位置--&gt; &quot;width&quot;: 100, &quot;height&quot;: 200, &quot;hOffset&quot;: 0, &quot;vOffset&quot;: 0 }, &quot;mobile&quot;: { &quot;show&quot;: true, &quot;scale&quot;: 0.5 }, &quot;react&quot;: { &quot;opacityDefault&quot;: 0.7, &lt;!--设置透明度--&gt; &quot;opacityOnHover&quot;: 0.2 } }); window.onload = function() { $(&quot;#live2dcanvas&quot;).attr(&quot;style&quot;, &quot;position: fixed; opacity: 0.7; left: 70px; bottom: 0px; z-index: 1; pointer-events: none;&quot;) } &lt;/script&gt; &lt;/div&gt; 白猫： &lt;!--白小猫咪--&gt; &lt;script src=&quot; https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.0.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; L2Dwidget.init({ &quot;model&quot;: { jsonPath: &quot; https://unpkg.com/live2d-widget-model-tororo@1.0.5/assets/tororo.model.json&quot; , &quot;scale&quot;: 1 }, &quot;display&quot;: { &quot;position&quot;: &quot;right&quot;, &quot;width&quot;: 100, &quot;height&quot;: 200, &quot;hOffset&quot;: -20, &quot;vOffset&quot;: -20 }, &quot;mobile&quot;: { &quot;show&quot;: true, &quot;scale&quot;: 0.5 }, &quot;react&quot;: { &quot;opacityDefault&quot;: 1, &quot;opacityOnHover&quot;: 1 } }); &lt;/script&gt; 鼠标点击出随机颜色的爱心: &lt;!--鼠标点击出随机颜色的爱心--&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 网页鼠标点击特效（爱心） --&gt; &lt;script type=&quot;text/javascript&quot;&gt; ! function (e, t, a) { function r() { for (var e = 0; e &lt; s.length; e++) s[e].alpha &lt;= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[ e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = &quot;left:&quot; + s[e].x + &quot;px;top:&quot; + s[e].y + &quot;px;opacity:&quot; + s[e].alpha + &quot;;transform:scale(&quot; + s[e].scale + &quot;,&quot; + s[e] .scale + &quot;) rotate(45deg);background:&quot; + s[e].color + &quot;;z-index:99999&quot;); requestAnimationFrame(r) } function n() { var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick; e.onclick = function (e) { t &amp;&amp; t(), o(e) } } function o(e) { var a = t.createElement(&quot;div&quot;); a.className = &quot;heart&quot;, s.push({ el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: c() }), t.body.appendChild(a) } function i(e) { var a = t.createElement(&quot;style&quot;); a.type = &quot;text/css&quot;; try { a.appendChild(t.createTextNode(e)) } catch (t) { a.styleSheet.cssText = e } t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) } function c() { return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math .random()) + &quot;)&quot; } var s = []; e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e .mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) { setTimeout(e, 1e3 / 60) }, i( &quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot; ), n(), r() }(window, document); &lt;/script&gt; 隐藏右上角复制直链、下载切换布局等： &lt;!--隐藏右上角--&gt; &lt;style&gt; .css-neion{ display:none; } &lt;/style&gt; 全白无框： &lt;!--全白无框--&gt; &lt;style&gt; .chakra-ui-light{ background-color: #FFFFFF; } .main-box { border-radius: 15px !important; box-shadow: unset !important; } .chakra-ui-light .main-box { background-color: rgba(255,255,255,0.9) !important; } .chakra-ui-light .readme-box { background-color: rgba(255,255,255,0.9) !important; } .readme-box { border-radius: 15px !important; box-shadow: unset !important; } &lt;/style&gt; 备案信息： &lt;!--备案信息--&gt; &lt;/style&gt; &lt;link href=&quot;https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css&quot; rel=&quot; stylesheet &quot;&gt; &lt;div id=&quot;customize&quot; style=&quot;display:none; text-align:center; &quot;&gt; &lt;br /&gt; &lt;div style=&quot;font-size:13px; &quot;&gt; &lt;span class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;http://lizong.top/&quot; target=&quot;_blank&quot;&gt; &lt;i class=&quot;fa-solid fa-copyright&quot; style=&quot;color:#9932CC&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 2022 LIZONG.TOP | &lt;/a&gt; &lt;/span&gt; &lt;span class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;https://beian.miit.gov.cn/&quot; target=&quot;_blank&quot;&gt; &lt;i class=&quot;fa fa-balance-scale&quot; style=&quot;color:#9932CC; &quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 鄂ICP备xxxxxx号-x | &lt;/a&gt; &lt;/span&gt; &lt;span class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;https://github.com/Xhofe/alist&quot; target=&quot;_blank&quot;&gt; &lt;i class=&quot;fa fa-heart&quot; style=&quot;color:#9932CC; &quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 由Alist驱动 &lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;br /&gt; &lt;/div&gt; &lt;script&gt; let interval = setInterval(() =&gt; { if (document.querySelector(&quot;.footer&quot;)) { document.querySelector(&quot;#customize&quot;).style.display = &quot;&quot;; clearInterval(interval); } },200); &lt;/script&gt; &lt;/font&gt; 底部网站运行时间： &lt;!--开站时间开始--&gt; &lt;center&gt; &lt;br /&gt; &lt;/span&gt; &lt;span class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;https://nodepanels.com/share/server?auth=c3ce0f96aab24a63b88044dede67165d&amp;key=MzkxZjI4OTI0ODJmNDg5MWFjZDFlZDI2ZmUwYTJiYTR8bDEzMTQ0QHFxLmNvbXxqYzhidHd4bmZueDQ=&quot; target=&quot;_blank&quot;&gt; &lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt; &lt;script language=&quot;javascript&quot;&gt; var now = new Date(); function createtime(){ var grt= new Date(&quot;04/17/2022 00:00:00&quot;);/*---这里是网站的启用时间--*/ now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 ){hnum = &quot;0&quot; + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = &quot;0&quot; + mnum;} seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 ){snum = &quot;0&quot; + snum;} document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;⏱️本站已稳定运行&quot;+dnum+&quot;天&quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot;小时&quot; + mnum + &quot;分&quot; + snum + &quot;秒&quot;; } setInterval(&quot;createtime()&quot;,250); &lt;/script&gt; 自定义背景：替换url即可 &lt;!--自定义背景--&gt; &lt;style&gt; .chakra-ui-light{ background-image: url(&quot;https://www.dmoe.cc/random.php&quot;) !important; background-repeat:no-repeat;background-size:cover;background-attachment:fixed;background-position-x:center; } .main-box { border-radius: 15px !important; } .chakra-ui-light .main-box { background-color: #ffffff70 !important; } .chakra-ui-light .readme-box { background-color: white !important; } .readme-box { border-radius: 15px !important; } &lt;/style&gt; 去掉底部的管理文字： &lt;!---去掉底部管理---&gt; &lt;style&gt; .footer span,.footer a:nth-of-type(2){ display:none; } &lt;/style&gt; 去掉底部的 Powered by Alist： &lt;!--去掉底部Powered by Alist---&gt; &lt;style&gt; .footer span,.footer a:nth-of-type(1){ display:none; } &lt;/style&gt; 去掉底部Powered by Alist和管理文字： &lt;!---去掉底部文字---&gt; &lt;style type=&quot;text/css&quot;&gt; .footer { display: none !important; } &lt;/style&gt; ","link":"https://gblw-blog.github.io/alist-chang-yong-yang-shi/"},{"title":"Mysql安装记录","content":" 通过SSH工具连接Linux系统 上传 mysql 的安装包 解压 mysql 的安装包 mkdir mysql tar -xvf mysql-5.7.27-1.el7.x86_64.rpm-bundle.tar -C mysql/ 安装客户端 cd mysql/ rpm -ivh mysql-community-client-5.7.27-1.el7.x86_64.rpm --force --nodeps 安装服务端 rpm -ivh mysql-community-server-5.7.27-1.el7.x86_64.rpm --force --nodeps 修改mysql默认字符集 vi /etc/my.cnf 添加如下内容： [mysqld] character-set-server=utf8 collation-server=utf8_general_ci -- 在文件最下方添加 [client] default-character-set=utf8 启动mysql服务 service mysqld start 登录mysql mysql -u root -p 敲回车，输入密码 初始密码查看：cat /var/log/mysqld.log 在root@localhost: 后面的就是初始密码 修改mysql登录密码 set global validate_password_policy=0; set global validate_password_length=1; set password=password('密码'); 授予远程连接权限 //授权 grant all privileges on . to 'root' @'%' identified by '密码'; //刷新 flush privileges; 关闭Linux系统防火墙 systemctl stop firewalld 重启mysql服务 service mysqld restart 使用SQLYog工具连接mysql ","link":"https://gblw-blog.github.io/mysql-an-zhuang-ji-lu/"},{"title":"常用shell脚本","content":"【x-ui】 bash &lt;(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh) 【Azure提取api】 az ad sp create-for-rbac --role contributor --scopes /subscriptions/$(az account list --query [].id -o tsv) 【聚合测试】 wget -O jcnfbox.sh https://raw.githubusercontent.com/Netflixxp/jcnf-box/main/jcnfbox.sh &amp;&amp; chmod +x jcnfbox.sh &amp;&amp; clear &amp;&amp; ./jcnfbox.sh 【BBR】 wget -N --no-check-certificate &quot;https://gist.github.com/zeruns/a0ec603f20d1b86de6a774a8ba27588f/raw/4f9957ae23f5efb2bb7c57a198ae2cffebfb1c56/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh 【Serverstatus】 wget https://cokemine.coding.net/p/hotarunet/d/ServerStatus-Hotaru/git/raw/master/status.sh 【Rclone】 curl https://rclone.org/install.sh | sudo bash 【Docker】 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 【FileBrowser】 bash &lt;(curl -s -L https://233blog.com/filebrowser.sh) 【Warp】 wget -O menu.sh https://cdn.jsdelivr.net/gh/fscarmen/warp/menu.sh &amp;&amp; bash menu.sh 【Aapanel助手】 wget https://ghproxy.com/https://raw.githubusercontent.com/AaronYES/aaPanel/main/script/aapanel.sh -O aapanel.sh &amp;&amp; chmod +x aapanel.sh &amp;&amp; clear &amp;&amp; ./aapanel.sh 【DD脚本】 wget -N --no-check-certificate https://down.vpsaff.net/linux/dd/network-reinstall-os.sh &amp;&amp; \\\\nchmod +x network-reinstall-os.sh &amp;&amp; ./network-reinstall-os.sh 【流媒体测试】 bash &lt;(curl -L -s check.unlock.media) 【回程路由测试】 curl https://raw.githubusercontent.com/zhucaidan/mtr_trace/main/mtr_trace.sh|bash 【添加Swap】 wget https://www.moerats.com/usr/shell/swap.sh &amp;&amp; bash swap.sh 【Vps线路测试】 wget --no-check-certificate https://tutu.ovh/bash/returnroute/route &amp;&amp; chmod +x route &amp;&amp; clear &amp;&amp; ./route try try 【后端对接】 bash &lt;(curl -Ls https://raw.githubusercontent.com/crossfw/Air-Universe-install/master/AirU.sh) ","link":"https://gblw-blog.github.io/chang-yong-shell-jiao-ben/"}]}